/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef Aim_H
#define Aim_H

#include <thrift/TDispatchProcessor.h>
#include "aim_types.h"



class AimIf {
 public:
  virtual ~AimIf() {}

  /**
   * Rimp procedures
   */
  virtual void checkRimpConfiguration() = 0;
  virtual int64_t getDiskFileSize(const std::string& virtualImageDatastorePath) = 0;
  virtual void getDatastores(std::vector<Datastore> & _return) = 0;
  virtual void getNetInterfaces(std::vector<NetInterface> & _return) = 0;
  virtual void copyFromRepositoryToDatastore(const std::string& virtualImageRepositoryPath, const std::string& datastorePath, const std::string& virtualMachineUUID) = 0;
  virtual void deleteVirtualImageFromDatastore(const std::string& datastorePath, const std::string& virtualMachineUUID) = 0;
  virtual void copyFromDatastoreToRepository(const std::string& virtualMachineUUID, const std::string& snapshot, const std::string& destinationRepositoryPath, const std::string& sourceDatastorePath) = 0;
  virtual void instanceDisk(const std::string& source, const std::string& destination) = 0;
  virtual void renameDisk(const std::string& oldPath, const std::string& newPath) = 0;

  /**
   * VLan procedures
   * 
   * @param vlanTag
   * @param vlanInterface
   * @param bridgeInterface
   */
  virtual void createVLAN(const int32_t vlanTag, const std::string& vlanInterface, const std::string& bridgeInterface) = 0;
  virtual void deleteVLAN(const int32_t vlanTag, const std::string& vlanInterface, const std::string& bridgeInterface) = 0;
  virtual void checkVLANConfiguration() = 0;

  /**
   * Storage configuration procedures
   */
  virtual void getInitiatorIQN(std::string& _return) = 0;
  virtual void rescanISCSI(const std::vector<std::string> & targets) = 0;

  /**
   * Libvirt procedures
   */
  virtual void getNodeInfo(NodeInfo& _return) = 0;
  virtual void defineDomain(const std::string& xmlDesc) = 0;
  virtual void undefineDomain(const std::string& domainName) = 0;
  virtual bool existDomain(const std::string& domainName) = 0;
  virtual DomainState::type getDomainState(const std::string& domainName) = 0;
  virtual void getDomainInfo(DomainInfo& _return, const std::string& domainName) = 0;
  virtual void getDomains(std::vector<DomainInfo> & _return) = 0;
  virtual void powerOn(const std::string& domainName) = 0;
  virtual void powerOff(const std::string& domainName) = 0;
  virtual void shutdown(const std::string& domainName) = 0;
  virtual void reset(const std::string& domainName) = 0;
  virtual void pause(const std::string& domainName) = 0;
  virtual void resume(const std::string& domainName) = 0;
  virtual void createISCSIStoragePool(const std::string& name, const std::string& host, const std::string& iqn, const std::string& targetPath) = 0;
  virtual void createNFSStoragePool(const std::string& name, const std::string& host, const std::string& dir, const std::string& targetPath) = 0;
  virtual void createDirStoragePool(const std::string& name, const std::string& targetPath) = 0;
  virtual void createDisk(const std::string& poolName, const std::string& name, const double capacityInKb, const double allocationInKb, const std::string& format) = 0;
  virtual void deleteDisk(const std::string& poolName, const std::string& name) = 0;
  virtual void resizeVol(const std::string& poolName, const std::string& name, const double capacityInKb) = 0;
  virtual void resizeDisk(const std::string& domainName, const std::string& diskPath, const double diskSizeInKb) = 0;
  virtual void getDomainBlockInfo(DomainBlockInfo& _return, const std::string& domainName, const std::string& diskPath) = 0;
  virtual void getDatapoints(std::vector<Measure> & _return, const std::string& domainName, const int32_t timestamp) = 0;
  virtual void upload(const BinaryFile& file, const std::string& path) = 0;
};

class AimIfFactory {
 public:
  typedef AimIf Handler;

  virtual ~AimIfFactory() {}

  virtual AimIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) = 0;
  virtual void releaseHandler(AimIf* /* handler */) = 0;
};

class AimIfSingletonFactory : virtual public AimIfFactory {
 public:
  AimIfSingletonFactory(const boost::shared_ptr<AimIf>& iface) : iface_(iface) {}
  virtual ~AimIfSingletonFactory() {}

  virtual AimIf* getHandler(const ::apache::thrift::TConnectionInfo&) {
    return iface_.get();
  }
  virtual void releaseHandler(AimIf* /* handler */) {}

 protected:
  boost::shared_ptr<AimIf> iface_;
};

class AimNull : virtual public AimIf {
 public:
  virtual ~AimNull() {}
  void checkRimpConfiguration() {
    return;
  }
  int64_t getDiskFileSize(const std::string& /* virtualImageDatastorePath */) {
    int64_t _return = 0;
    return _return;
  }
  void getDatastores(std::vector<Datastore> & /* _return */) {
    return;
  }
  void getNetInterfaces(std::vector<NetInterface> & /* _return */) {
    return;
  }
  void copyFromRepositoryToDatastore(const std::string& /* virtualImageRepositoryPath */, const std::string& /* datastorePath */, const std::string& /* virtualMachineUUID */) {
    return;
  }
  void deleteVirtualImageFromDatastore(const std::string& /* datastorePath */, const std::string& /* virtualMachineUUID */) {
    return;
  }
  void copyFromDatastoreToRepository(const std::string& /* virtualMachineUUID */, const std::string& /* snapshot */, const std::string& /* destinationRepositoryPath */, const std::string& /* sourceDatastorePath */) {
    return;
  }
  void instanceDisk(const std::string& /* source */, const std::string& /* destination */) {
    return;
  }
  void renameDisk(const std::string& /* oldPath */, const std::string& /* newPath */) {
    return;
  }
  void createVLAN(const int32_t /* vlanTag */, const std::string& /* vlanInterface */, const std::string& /* bridgeInterface */) {
    return;
  }
  void deleteVLAN(const int32_t /* vlanTag */, const std::string& /* vlanInterface */, const std::string& /* bridgeInterface */) {
    return;
  }
  void checkVLANConfiguration() {
    return;
  }
  void getInitiatorIQN(std::string& /* _return */) {
    return;
  }
  void rescanISCSI(const std::vector<std::string> & /* targets */) {
    return;
  }
  void getNodeInfo(NodeInfo& /* _return */) {
    return;
  }
  void defineDomain(const std::string& /* xmlDesc */) {
    return;
  }
  void undefineDomain(const std::string& /* domainName */) {
    return;
  }
  bool existDomain(const std::string& /* domainName */) {
    bool _return = false;
    return _return;
  }
  DomainState::type getDomainState(const std::string& /* domainName */) {
    DomainState::type _return = (DomainState::type)0;
    return _return;
  }
  void getDomainInfo(DomainInfo& /* _return */, const std::string& /* domainName */) {
    return;
  }
  void getDomains(std::vector<DomainInfo> & /* _return */) {
    return;
  }
  void powerOn(const std::string& /* domainName */) {
    return;
  }
  void powerOff(const std::string& /* domainName */) {
    return;
  }
  void shutdown(const std::string& /* domainName */) {
    return;
  }
  void reset(const std::string& /* domainName */) {
    return;
  }
  void pause(const std::string& /* domainName */) {
    return;
  }
  void resume(const std::string& /* domainName */) {
    return;
  }
  void createISCSIStoragePool(const std::string& /* name */, const std::string& /* host */, const std::string& /* iqn */, const std::string& /* targetPath */) {
    return;
  }
  void createNFSStoragePool(const std::string& /* name */, const std::string& /* host */, const std::string& /* dir */, const std::string& /* targetPath */) {
    return;
  }
  void createDirStoragePool(const std::string& /* name */, const std::string& /* targetPath */) {
    return;
  }
  void createDisk(const std::string& /* poolName */, const std::string& /* name */, const double /* capacityInKb */, const double /* allocationInKb */, const std::string& /* format */) {
    return;
  }
  void deleteDisk(const std::string& /* poolName */, const std::string& /* name */) {
    return;
  }
  void resizeVol(const std::string& /* poolName */, const std::string& /* name */, const double /* capacityInKb */) {
    return;
  }
  void resizeDisk(const std::string& /* domainName */, const std::string& /* diskPath */, const double /* diskSizeInKb */) {
    return;
  }
  void getDomainBlockInfo(DomainBlockInfo& /* _return */, const std::string& /* domainName */, const std::string& /* diskPath */) {
    return;
  }
  void getDatapoints(std::vector<Measure> & /* _return */, const std::string& /* domainName */, const int32_t /* timestamp */) {
    return;
  }
  void upload(const BinaryFile& /* file */, const std::string& /* path */) {
    return;
  }
};


class Aim_checkRimpConfiguration_args {
 public:

  static const char* ascii_fingerprint; // = "99914B932BD37A50B983C5E7C90AE93B";
  static const uint8_t binary_fingerprint[16]; // = {0x99,0x91,0x4B,0x93,0x2B,0xD3,0x7A,0x50,0xB9,0x83,0xC5,0xE7,0xC9,0x0A,0xE9,0x3B};

  Aim_checkRimpConfiguration_args(const Aim_checkRimpConfiguration_args&);
  Aim_checkRimpConfiguration_args& operator=(const Aim_checkRimpConfiguration_args&);
  Aim_checkRimpConfiguration_args() {
  }

  virtual ~Aim_checkRimpConfiguration_args() throw();

  bool operator == (const Aim_checkRimpConfiguration_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Aim_checkRimpConfiguration_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_checkRimpConfiguration_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_checkRimpConfiguration_args& obj);
};


class Aim_checkRimpConfiguration_pargs {
 public:

  static const char* ascii_fingerprint; // = "99914B932BD37A50B983C5E7C90AE93B";
  static const uint8_t binary_fingerprint[16]; // = {0x99,0x91,0x4B,0x93,0x2B,0xD3,0x7A,0x50,0xB9,0x83,0xC5,0xE7,0xC9,0x0A,0xE9,0x3B};


  virtual ~Aim_checkRimpConfiguration_pargs() throw();

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_checkRimpConfiguration_pargs& obj);
};

typedef struct _Aim_checkRimpConfiguration_result__isset {
  _Aim_checkRimpConfiguration_result__isset() : re(false) {}
  bool re :1;
} _Aim_checkRimpConfiguration_result__isset;

class Aim_checkRimpConfiguration_result {
 public:

  static const char* ascii_fingerprint; // = "771E7EF40B572D2BFAB12C49547ADCBF";
  static const uint8_t binary_fingerprint[16]; // = {0x77,0x1E,0x7E,0xF4,0x0B,0x57,0x2D,0x2B,0xFA,0xB1,0x2C,0x49,0x54,0x7A,0xDC,0xBF};

  Aim_checkRimpConfiguration_result(const Aim_checkRimpConfiguration_result&);
  Aim_checkRimpConfiguration_result& operator=(const Aim_checkRimpConfiguration_result&);
  Aim_checkRimpConfiguration_result() {
  }

  virtual ~Aim_checkRimpConfiguration_result() throw();
  RimpException re;

  _Aim_checkRimpConfiguration_result__isset __isset;

  void __set_re(const RimpException& val);

  bool operator == (const Aim_checkRimpConfiguration_result & rhs) const
  {
    if (!(re == rhs.re))
      return false;
    return true;
  }
  bool operator != (const Aim_checkRimpConfiguration_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_checkRimpConfiguration_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_checkRimpConfiguration_result& obj);
};

typedef struct _Aim_checkRimpConfiguration_presult__isset {
  _Aim_checkRimpConfiguration_presult__isset() : re(false) {}
  bool re :1;
} _Aim_checkRimpConfiguration_presult__isset;

class Aim_checkRimpConfiguration_presult {
 public:

  static const char* ascii_fingerprint; // = "771E7EF40B572D2BFAB12C49547ADCBF";
  static const uint8_t binary_fingerprint[16]; // = {0x77,0x1E,0x7E,0xF4,0x0B,0x57,0x2D,0x2B,0xFA,0xB1,0x2C,0x49,0x54,0x7A,0xDC,0xBF};


  virtual ~Aim_checkRimpConfiguration_presult() throw();
  RimpException re;

  _Aim_checkRimpConfiguration_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Aim_checkRimpConfiguration_presult& obj);
};

typedef struct _Aim_getDiskFileSize_args__isset {
  _Aim_getDiskFileSize_args__isset() : virtualImageDatastorePath(false) {}
  bool virtualImageDatastorePath :1;
} _Aim_getDiskFileSize_args__isset;

class Aim_getDiskFileSize_args {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  Aim_getDiskFileSize_args(const Aim_getDiskFileSize_args&);
  Aim_getDiskFileSize_args& operator=(const Aim_getDiskFileSize_args&);
  Aim_getDiskFileSize_args() : virtualImageDatastorePath() {
  }

  virtual ~Aim_getDiskFileSize_args() throw();
  std::string virtualImageDatastorePath;

  _Aim_getDiskFileSize_args__isset __isset;

  void __set_virtualImageDatastorePath(const std::string& val);

  bool operator == (const Aim_getDiskFileSize_args & rhs) const
  {
    if (!(virtualImageDatastorePath == rhs.virtualImageDatastorePath))
      return false;
    return true;
  }
  bool operator != (const Aim_getDiskFileSize_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_getDiskFileSize_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_getDiskFileSize_args& obj);
};


class Aim_getDiskFileSize_pargs {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};


  virtual ~Aim_getDiskFileSize_pargs() throw();
  const std::string* virtualImageDatastorePath;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_getDiskFileSize_pargs& obj);
};

typedef struct _Aim_getDiskFileSize_result__isset {
  _Aim_getDiskFileSize_result__isset() : success(false), re(false) {}
  bool success :1;
  bool re :1;
} _Aim_getDiskFileSize_result__isset;

class Aim_getDiskFileSize_result {
 public:

  static const char* ascii_fingerprint; // = "508103C02ABBB83FE53EB7316CA5F1B7";
  static const uint8_t binary_fingerprint[16]; // = {0x50,0x81,0x03,0xC0,0x2A,0xBB,0xB8,0x3F,0xE5,0x3E,0xB7,0x31,0x6C,0xA5,0xF1,0xB7};

  Aim_getDiskFileSize_result(const Aim_getDiskFileSize_result&);
  Aim_getDiskFileSize_result& operator=(const Aim_getDiskFileSize_result&);
  Aim_getDiskFileSize_result() : success(0) {
  }

  virtual ~Aim_getDiskFileSize_result() throw();
  int64_t success;
  RimpException re;

  _Aim_getDiskFileSize_result__isset __isset;

  void __set_success(const int64_t val);

  void __set_re(const RimpException& val);

  bool operator == (const Aim_getDiskFileSize_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(re == rhs.re))
      return false;
    return true;
  }
  bool operator != (const Aim_getDiskFileSize_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_getDiskFileSize_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_getDiskFileSize_result& obj);
};

typedef struct _Aim_getDiskFileSize_presult__isset {
  _Aim_getDiskFileSize_presult__isset() : success(false), re(false) {}
  bool success :1;
  bool re :1;
} _Aim_getDiskFileSize_presult__isset;

class Aim_getDiskFileSize_presult {
 public:

  static const char* ascii_fingerprint; // = "508103C02ABBB83FE53EB7316CA5F1B7";
  static const uint8_t binary_fingerprint[16]; // = {0x50,0x81,0x03,0xC0,0x2A,0xBB,0xB8,0x3F,0xE5,0x3E,0xB7,0x31,0x6C,0xA5,0xF1,0xB7};


  virtual ~Aim_getDiskFileSize_presult() throw();
  int64_t* success;
  RimpException re;

  _Aim_getDiskFileSize_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Aim_getDiskFileSize_presult& obj);
};


class Aim_getDatastores_args {
 public:

  static const char* ascii_fingerprint; // = "99914B932BD37A50B983C5E7C90AE93B";
  static const uint8_t binary_fingerprint[16]; // = {0x99,0x91,0x4B,0x93,0x2B,0xD3,0x7A,0x50,0xB9,0x83,0xC5,0xE7,0xC9,0x0A,0xE9,0x3B};

  Aim_getDatastores_args(const Aim_getDatastores_args&);
  Aim_getDatastores_args& operator=(const Aim_getDatastores_args&);
  Aim_getDatastores_args() {
  }

  virtual ~Aim_getDatastores_args() throw();

  bool operator == (const Aim_getDatastores_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Aim_getDatastores_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_getDatastores_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_getDatastores_args& obj);
};


class Aim_getDatastores_pargs {
 public:

  static const char* ascii_fingerprint; // = "99914B932BD37A50B983C5E7C90AE93B";
  static const uint8_t binary_fingerprint[16]; // = {0x99,0x91,0x4B,0x93,0x2B,0xD3,0x7A,0x50,0xB9,0x83,0xC5,0xE7,0xC9,0x0A,0xE9,0x3B};


  virtual ~Aim_getDatastores_pargs() throw();

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_getDatastores_pargs& obj);
};

typedef struct _Aim_getDatastores_result__isset {
  _Aim_getDatastores_result__isset() : success(false), re(false) {}
  bool success :1;
  bool re :1;
} _Aim_getDatastores_result__isset;

class Aim_getDatastores_result {
 public:

  static const char* ascii_fingerprint; // = "47EF84C9D3C6CDEC0D1A5EE1EF46AF69";
  static const uint8_t binary_fingerprint[16]; // = {0x47,0xEF,0x84,0xC9,0xD3,0xC6,0xCD,0xEC,0x0D,0x1A,0x5E,0xE1,0xEF,0x46,0xAF,0x69};

  Aim_getDatastores_result(const Aim_getDatastores_result&);
  Aim_getDatastores_result& operator=(const Aim_getDatastores_result&);
  Aim_getDatastores_result() {
  }

  virtual ~Aim_getDatastores_result() throw();
  std::vector<Datastore>  success;
  RimpException re;

  _Aim_getDatastores_result__isset __isset;

  void __set_success(const std::vector<Datastore> & val);

  void __set_re(const RimpException& val);

  bool operator == (const Aim_getDatastores_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(re == rhs.re))
      return false;
    return true;
  }
  bool operator != (const Aim_getDatastores_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_getDatastores_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_getDatastores_result& obj);
};

typedef struct _Aim_getDatastores_presult__isset {
  _Aim_getDatastores_presult__isset() : success(false), re(false) {}
  bool success :1;
  bool re :1;
} _Aim_getDatastores_presult__isset;

class Aim_getDatastores_presult {
 public:

  static const char* ascii_fingerprint; // = "47EF84C9D3C6CDEC0D1A5EE1EF46AF69";
  static const uint8_t binary_fingerprint[16]; // = {0x47,0xEF,0x84,0xC9,0xD3,0xC6,0xCD,0xEC,0x0D,0x1A,0x5E,0xE1,0xEF,0x46,0xAF,0x69};


  virtual ~Aim_getDatastores_presult() throw();
  std::vector<Datastore> * success;
  RimpException re;

  _Aim_getDatastores_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Aim_getDatastores_presult& obj);
};


class Aim_getNetInterfaces_args {
 public:

  static const char* ascii_fingerprint; // = "99914B932BD37A50B983C5E7C90AE93B";
  static const uint8_t binary_fingerprint[16]; // = {0x99,0x91,0x4B,0x93,0x2B,0xD3,0x7A,0x50,0xB9,0x83,0xC5,0xE7,0xC9,0x0A,0xE9,0x3B};

  Aim_getNetInterfaces_args(const Aim_getNetInterfaces_args&);
  Aim_getNetInterfaces_args& operator=(const Aim_getNetInterfaces_args&);
  Aim_getNetInterfaces_args() {
  }

  virtual ~Aim_getNetInterfaces_args() throw();

  bool operator == (const Aim_getNetInterfaces_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Aim_getNetInterfaces_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_getNetInterfaces_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_getNetInterfaces_args& obj);
};


class Aim_getNetInterfaces_pargs {
 public:

  static const char* ascii_fingerprint; // = "99914B932BD37A50B983C5E7C90AE93B";
  static const uint8_t binary_fingerprint[16]; // = {0x99,0x91,0x4B,0x93,0x2B,0xD3,0x7A,0x50,0xB9,0x83,0xC5,0xE7,0xC9,0x0A,0xE9,0x3B};


  virtual ~Aim_getNetInterfaces_pargs() throw();

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_getNetInterfaces_pargs& obj);
};

typedef struct _Aim_getNetInterfaces_result__isset {
  _Aim_getNetInterfaces_result__isset() : success(false), re(false) {}
  bool success :1;
  bool re :1;
} _Aim_getNetInterfaces_result__isset;

class Aim_getNetInterfaces_result {
 public:

  static const char* ascii_fingerprint; // = "C117F90003DA4545F112D73EBD613259";
  static const uint8_t binary_fingerprint[16]; // = {0xC1,0x17,0xF9,0x00,0x03,0xDA,0x45,0x45,0xF1,0x12,0xD7,0x3E,0xBD,0x61,0x32,0x59};

  Aim_getNetInterfaces_result(const Aim_getNetInterfaces_result&);
  Aim_getNetInterfaces_result& operator=(const Aim_getNetInterfaces_result&);
  Aim_getNetInterfaces_result() {
  }

  virtual ~Aim_getNetInterfaces_result() throw();
  std::vector<NetInterface>  success;
  RimpException re;

  _Aim_getNetInterfaces_result__isset __isset;

  void __set_success(const std::vector<NetInterface> & val);

  void __set_re(const RimpException& val);

  bool operator == (const Aim_getNetInterfaces_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(re == rhs.re))
      return false;
    return true;
  }
  bool operator != (const Aim_getNetInterfaces_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_getNetInterfaces_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_getNetInterfaces_result& obj);
};

typedef struct _Aim_getNetInterfaces_presult__isset {
  _Aim_getNetInterfaces_presult__isset() : success(false), re(false) {}
  bool success :1;
  bool re :1;
} _Aim_getNetInterfaces_presult__isset;

class Aim_getNetInterfaces_presult {
 public:

  static const char* ascii_fingerprint; // = "C117F90003DA4545F112D73EBD613259";
  static const uint8_t binary_fingerprint[16]; // = {0xC1,0x17,0xF9,0x00,0x03,0xDA,0x45,0x45,0xF1,0x12,0xD7,0x3E,0xBD,0x61,0x32,0x59};


  virtual ~Aim_getNetInterfaces_presult() throw();
  std::vector<NetInterface> * success;
  RimpException re;

  _Aim_getNetInterfaces_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Aim_getNetInterfaces_presult& obj);
};

typedef struct _Aim_copyFromRepositoryToDatastore_args__isset {
  _Aim_copyFromRepositoryToDatastore_args__isset() : virtualImageRepositoryPath(false), datastorePath(false), virtualMachineUUID(false) {}
  bool virtualImageRepositoryPath :1;
  bool datastorePath :1;
  bool virtualMachineUUID :1;
} _Aim_copyFromRepositoryToDatastore_args__isset;

class Aim_copyFromRepositoryToDatastore_args {
 public:

  static const char* ascii_fingerprint; // = "AB879940BD15B6B25691265F7384B271";
  static const uint8_t binary_fingerprint[16]; // = {0xAB,0x87,0x99,0x40,0xBD,0x15,0xB6,0xB2,0x56,0x91,0x26,0x5F,0x73,0x84,0xB2,0x71};

  Aim_copyFromRepositoryToDatastore_args(const Aim_copyFromRepositoryToDatastore_args&);
  Aim_copyFromRepositoryToDatastore_args& operator=(const Aim_copyFromRepositoryToDatastore_args&);
  Aim_copyFromRepositoryToDatastore_args() : virtualImageRepositoryPath(), datastorePath(), virtualMachineUUID() {
  }

  virtual ~Aim_copyFromRepositoryToDatastore_args() throw();
  std::string virtualImageRepositoryPath;
  std::string datastorePath;
  std::string virtualMachineUUID;

  _Aim_copyFromRepositoryToDatastore_args__isset __isset;

  void __set_virtualImageRepositoryPath(const std::string& val);

  void __set_datastorePath(const std::string& val);

  void __set_virtualMachineUUID(const std::string& val);

  bool operator == (const Aim_copyFromRepositoryToDatastore_args & rhs) const
  {
    if (!(virtualImageRepositoryPath == rhs.virtualImageRepositoryPath))
      return false;
    if (!(datastorePath == rhs.datastorePath))
      return false;
    if (!(virtualMachineUUID == rhs.virtualMachineUUID))
      return false;
    return true;
  }
  bool operator != (const Aim_copyFromRepositoryToDatastore_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_copyFromRepositoryToDatastore_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_copyFromRepositoryToDatastore_args& obj);
};


class Aim_copyFromRepositoryToDatastore_pargs {
 public:

  static const char* ascii_fingerprint; // = "AB879940BD15B6B25691265F7384B271";
  static const uint8_t binary_fingerprint[16]; // = {0xAB,0x87,0x99,0x40,0xBD,0x15,0xB6,0xB2,0x56,0x91,0x26,0x5F,0x73,0x84,0xB2,0x71};


  virtual ~Aim_copyFromRepositoryToDatastore_pargs() throw();
  const std::string* virtualImageRepositoryPath;
  const std::string* datastorePath;
  const std::string* virtualMachineUUID;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_copyFromRepositoryToDatastore_pargs& obj);
};

typedef struct _Aim_copyFromRepositoryToDatastore_result__isset {
  _Aim_copyFromRepositoryToDatastore_result__isset() : re(false) {}
  bool re :1;
} _Aim_copyFromRepositoryToDatastore_result__isset;

class Aim_copyFromRepositoryToDatastore_result {
 public:

  static const char* ascii_fingerprint; // = "771E7EF40B572D2BFAB12C49547ADCBF";
  static const uint8_t binary_fingerprint[16]; // = {0x77,0x1E,0x7E,0xF4,0x0B,0x57,0x2D,0x2B,0xFA,0xB1,0x2C,0x49,0x54,0x7A,0xDC,0xBF};

  Aim_copyFromRepositoryToDatastore_result(const Aim_copyFromRepositoryToDatastore_result&);
  Aim_copyFromRepositoryToDatastore_result& operator=(const Aim_copyFromRepositoryToDatastore_result&);
  Aim_copyFromRepositoryToDatastore_result() {
  }

  virtual ~Aim_copyFromRepositoryToDatastore_result() throw();
  RimpException re;

  _Aim_copyFromRepositoryToDatastore_result__isset __isset;

  void __set_re(const RimpException& val);

  bool operator == (const Aim_copyFromRepositoryToDatastore_result & rhs) const
  {
    if (!(re == rhs.re))
      return false;
    return true;
  }
  bool operator != (const Aim_copyFromRepositoryToDatastore_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_copyFromRepositoryToDatastore_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_copyFromRepositoryToDatastore_result& obj);
};

typedef struct _Aim_copyFromRepositoryToDatastore_presult__isset {
  _Aim_copyFromRepositoryToDatastore_presult__isset() : re(false) {}
  bool re :1;
} _Aim_copyFromRepositoryToDatastore_presult__isset;

class Aim_copyFromRepositoryToDatastore_presult {
 public:

  static const char* ascii_fingerprint; // = "771E7EF40B572D2BFAB12C49547ADCBF";
  static const uint8_t binary_fingerprint[16]; // = {0x77,0x1E,0x7E,0xF4,0x0B,0x57,0x2D,0x2B,0xFA,0xB1,0x2C,0x49,0x54,0x7A,0xDC,0xBF};


  virtual ~Aim_copyFromRepositoryToDatastore_presult() throw();
  RimpException re;

  _Aim_copyFromRepositoryToDatastore_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Aim_copyFromRepositoryToDatastore_presult& obj);
};

typedef struct _Aim_deleteVirtualImageFromDatastore_args__isset {
  _Aim_deleteVirtualImageFromDatastore_args__isset() : datastorePath(false), virtualMachineUUID(false) {}
  bool datastorePath :1;
  bool virtualMachineUUID :1;
} _Aim_deleteVirtualImageFromDatastore_args__isset;

class Aim_deleteVirtualImageFromDatastore_args {
 public:

  static const char* ascii_fingerprint; // = "07A9615F837F7D0A952B595DD3020972";
  static const uint8_t binary_fingerprint[16]; // = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};

  Aim_deleteVirtualImageFromDatastore_args(const Aim_deleteVirtualImageFromDatastore_args&);
  Aim_deleteVirtualImageFromDatastore_args& operator=(const Aim_deleteVirtualImageFromDatastore_args&);
  Aim_deleteVirtualImageFromDatastore_args() : datastorePath(), virtualMachineUUID() {
  }

  virtual ~Aim_deleteVirtualImageFromDatastore_args() throw();
  std::string datastorePath;
  std::string virtualMachineUUID;

  _Aim_deleteVirtualImageFromDatastore_args__isset __isset;

  void __set_datastorePath(const std::string& val);

  void __set_virtualMachineUUID(const std::string& val);

  bool operator == (const Aim_deleteVirtualImageFromDatastore_args & rhs) const
  {
    if (!(datastorePath == rhs.datastorePath))
      return false;
    if (!(virtualMachineUUID == rhs.virtualMachineUUID))
      return false;
    return true;
  }
  bool operator != (const Aim_deleteVirtualImageFromDatastore_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_deleteVirtualImageFromDatastore_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_deleteVirtualImageFromDatastore_args& obj);
};


class Aim_deleteVirtualImageFromDatastore_pargs {
 public:

  static const char* ascii_fingerprint; // = "07A9615F837F7D0A952B595DD3020972";
  static const uint8_t binary_fingerprint[16]; // = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};


  virtual ~Aim_deleteVirtualImageFromDatastore_pargs() throw();
  const std::string* datastorePath;
  const std::string* virtualMachineUUID;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_deleteVirtualImageFromDatastore_pargs& obj);
};

typedef struct _Aim_deleteVirtualImageFromDatastore_result__isset {
  _Aim_deleteVirtualImageFromDatastore_result__isset() : re(false) {}
  bool re :1;
} _Aim_deleteVirtualImageFromDatastore_result__isset;

class Aim_deleteVirtualImageFromDatastore_result {
 public:

  static const char* ascii_fingerprint; // = "771E7EF40B572D2BFAB12C49547ADCBF";
  static const uint8_t binary_fingerprint[16]; // = {0x77,0x1E,0x7E,0xF4,0x0B,0x57,0x2D,0x2B,0xFA,0xB1,0x2C,0x49,0x54,0x7A,0xDC,0xBF};

  Aim_deleteVirtualImageFromDatastore_result(const Aim_deleteVirtualImageFromDatastore_result&);
  Aim_deleteVirtualImageFromDatastore_result& operator=(const Aim_deleteVirtualImageFromDatastore_result&);
  Aim_deleteVirtualImageFromDatastore_result() {
  }

  virtual ~Aim_deleteVirtualImageFromDatastore_result() throw();
  RimpException re;

  _Aim_deleteVirtualImageFromDatastore_result__isset __isset;

  void __set_re(const RimpException& val);

  bool operator == (const Aim_deleteVirtualImageFromDatastore_result & rhs) const
  {
    if (!(re == rhs.re))
      return false;
    return true;
  }
  bool operator != (const Aim_deleteVirtualImageFromDatastore_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_deleteVirtualImageFromDatastore_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_deleteVirtualImageFromDatastore_result& obj);
};

typedef struct _Aim_deleteVirtualImageFromDatastore_presult__isset {
  _Aim_deleteVirtualImageFromDatastore_presult__isset() : re(false) {}
  bool re :1;
} _Aim_deleteVirtualImageFromDatastore_presult__isset;

class Aim_deleteVirtualImageFromDatastore_presult {
 public:

  static const char* ascii_fingerprint; // = "771E7EF40B572D2BFAB12C49547ADCBF";
  static const uint8_t binary_fingerprint[16]; // = {0x77,0x1E,0x7E,0xF4,0x0B,0x57,0x2D,0x2B,0xFA,0xB1,0x2C,0x49,0x54,0x7A,0xDC,0xBF};


  virtual ~Aim_deleteVirtualImageFromDatastore_presult() throw();
  RimpException re;

  _Aim_deleteVirtualImageFromDatastore_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Aim_deleteVirtualImageFromDatastore_presult& obj);
};

typedef struct _Aim_copyFromDatastoreToRepository_args__isset {
  _Aim_copyFromDatastoreToRepository_args__isset() : virtualMachineUUID(false), snapshot(false), destinationRepositoryPath(false), sourceDatastorePath(false) {}
  bool virtualMachineUUID :1;
  bool snapshot :1;
  bool destinationRepositoryPath :1;
  bool sourceDatastorePath :1;
} _Aim_copyFromDatastoreToRepository_args__isset;

class Aim_copyFromDatastoreToRepository_args {
 public:

  static const char* ascii_fingerprint; // = "C93D890311F28844166CF6E571EB3AC2";
  static const uint8_t binary_fingerprint[16]; // = {0xC9,0x3D,0x89,0x03,0x11,0xF2,0x88,0x44,0x16,0x6C,0xF6,0xE5,0x71,0xEB,0x3A,0xC2};

  Aim_copyFromDatastoreToRepository_args(const Aim_copyFromDatastoreToRepository_args&);
  Aim_copyFromDatastoreToRepository_args& operator=(const Aim_copyFromDatastoreToRepository_args&);
  Aim_copyFromDatastoreToRepository_args() : virtualMachineUUID(), snapshot(), destinationRepositoryPath(), sourceDatastorePath() {
  }

  virtual ~Aim_copyFromDatastoreToRepository_args() throw();
  std::string virtualMachineUUID;
  std::string snapshot;
  std::string destinationRepositoryPath;
  std::string sourceDatastorePath;

  _Aim_copyFromDatastoreToRepository_args__isset __isset;

  void __set_virtualMachineUUID(const std::string& val);

  void __set_snapshot(const std::string& val);

  void __set_destinationRepositoryPath(const std::string& val);

  void __set_sourceDatastorePath(const std::string& val);

  bool operator == (const Aim_copyFromDatastoreToRepository_args & rhs) const
  {
    if (!(virtualMachineUUID == rhs.virtualMachineUUID))
      return false;
    if (!(snapshot == rhs.snapshot))
      return false;
    if (!(destinationRepositoryPath == rhs.destinationRepositoryPath))
      return false;
    if (!(sourceDatastorePath == rhs.sourceDatastorePath))
      return false;
    return true;
  }
  bool operator != (const Aim_copyFromDatastoreToRepository_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_copyFromDatastoreToRepository_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_copyFromDatastoreToRepository_args& obj);
};


class Aim_copyFromDatastoreToRepository_pargs {
 public:

  static const char* ascii_fingerprint; // = "C93D890311F28844166CF6E571EB3AC2";
  static const uint8_t binary_fingerprint[16]; // = {0xC9,0x3D,0x89,0x03,0x11,0xF2,0x88,0x44,0x16,0x6C,0xF6,0xE5,0x71,0xEB,0x3A,0xC2};


  virtual ~Aim_copyFromDatastoreToRepository_pargs() throw();
  const std::string* virtualMachineUUID;
  const std::string* snapshot;
  const std::string* destinationRepositoryPath;
  const std::string* sourceDatastorePath;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_copyFromDatastoreToRepository_pargs& obj);
};

typedef struct _Aim_copyFromDatastoreToRepository_result__isset {
  _Aim_copyFromDatastoreToRepository_result__isset() : re(false) {}
  bool re :1;
} _Aim_copyFromDatastoreToRepository_result__isset;

class Aim_copyFromDatastoreToRepository_result {
 public:

  static const char* ascii_fingerprint; // = "771E7EF40B572D2BFAB12C49547ADCBF";
  static const uint8_t binary_fingerprint[16]; // = {0x77,0x1E,0x7E,0xF4,0x0B,0x57,0x2D,0x2B,0xFA,0xB1,0x2C,0x49,0x54,0x7A,0xDC,0xBF};

  Aim_copyFromDatastoreToRepository_result(const Aim_copyFromDatastoreToRepository_result&);
  Aim_copyFromDatastoreToRepository_result& operator=(const Aim_copyFromDatastoreToRepository_result&);
  Aim_copyFromDatastoreToRepository_result() {
  }

  virtual ~Aim_copyFromDatastoreToRepository_result() throw();
  RimpException re;

  _Aim_copyFromDatastoreToRepository_result__isset __isset;

  void __set_re(const RimpException& val);

  bool operator == (const Aim_copyFromDatastoreToRepository_result & rhs) const
  {
    if (!(re == rhs.re))
      return false;
    return true;
  }
  bool operator != (const Aim_copyFromDatastoreToRepository_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_copyFromDatastoreToRepository_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_copyFromDatastoreToRepository_result& obj);
};

typedef struct _Aim_copyFromDatastoreToRepository_presult__isset {
  _Aim_copyFromDatastoreToRepository_presult__isset() : re(false) {}
  bool re :1;
} _Aim_copyFromDatastoreToRepository_presult__isset;

class Aim_copyFromDatastoreToRepository_presult {
 public:

  static const char* ascii_fingerprint; // = "771E7EF40B572D2BFAB12C49547ADCBF";
  static const uint8_t binary_fingerprint[16]; // = {0x77,0x1E,0x7E,0xF4,0x0B,0x57,0x2D,0x2B,0xFA,0xB1,0x2C,0x49,0x54,0x7A,0xDC,0xBF};


  virtual ~Aim_copyFromDatastoreToRepository_presult() throw();
  RimpException re;

  _Aim_copyFromDatastoreToRepository_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Aim_copyFromDatastoreToRepository_presult& obj);
};

typedef struct _Aim_instanceDisk_args__isset {
  _Aim_instanceDisk_args__isset() : source(false), destination(false) {}
  bool source :1;
  bool destination :1;
} _Aim_instanceDisk_args__isset;

class Aim_instanceDisk_args {
 public:

  static const char* ascii_fingerprint; // = "07A9615F837F7D0A952B595DD3020972";
  static const uint8_t binary_fingerprint[16]; // = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};

  Aim_instanceDisk_args(const Aim_instanceDisk_args&);
  Aim_instanceDisk_args& operator=(const Aim_instanceDisk_args&);
  Aim_instanceDisk_args() : source(), destination() {
  }

  virtual ~Aim_instanceDisk_args() throw();
  std::string source;
  std::string destination;

  _Aim_instanceDisk_args__isset __isset;

  void __set_source(const std::string& val);

  void __set_destination(const std::string& val);

  bool operator == (const Aim_instanceDisk_args & rhs) const
  {
    if (!(source == rhs.source))
      return false;
    if (!(destination == rhs.destination))
      return false;
    return true;
  }
  bool operator != (const Aim_instanceDisk_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_instanceDisk_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_instanceDisk_args& obj);
};


class Aim_instanceDisk_pargs {
 public:

  static const char* ascii_fingerprint; // = "07A9615F837F7D0A952B595DD3020972";
  static const uint8_t binary_fingerprint[16]; // = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};


  virtual ~Aim_instanceDisk_pargs() throw();
  const std::string* source;
  const std::string* destination;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_instanceDisk_pargs& obj);
};

typedef struct _Aim_instanceDisk_result__isset {
  _Aim_instanceDisk_result__isset() : re(false) {}
  bool re :1;
} _Aim_instanceDisk_result__isset;

class Aim_instanceDisk_result {
 public:

  static const char* ascii_fingerprint; // = "771E7EF40B572D2BFAB12C49547ADCBF";
  static const uint8_t binary_fingerprint[16]; // = {0x77,0x1E,0x7E,0xF4,0x0B,0x57,0x2D,0x2B,0xFA,0xB1,0x2C,0x49,0x54,0x7A,0xDC,0xBF};

  Aim_instanceDisk_result(const Aim_instanceDisk_result&);
  Aim_instanceDisk_result& operator=(const Aim_instanceDisk_result&);
  Aim_instanceDisk_result() {
  }

  virtual ~Aim_instanceDisk_result() throw();
  RimpException re;

  _Aim_instanceDisk_result__isset __isset;

  void __set_re(const RimpException& val);

  bool operator == (const Aim_instanceDisk_result & rhs) const
  {
    if (!(re == rhs.re))
      return false;
    return true;
  }
  bool operator != (const Aim_instanceDisk_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_instanceDisk_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_instanceDisk_result& obj);
};

typedef struct _Aim_instanceDisk_presult__isset {
  _Aim_instanceDisk_presult__isset() : re(false) {}
  bool re :1;
} _Aim_instanceDisk_presult__isset;

class Aim_instanceDisk_presult {
 public:

  static const char* ascii_fingerprint; // = "771E7EF40B572D2BFAB12C49547ADCBF";
  static const uint8_t binary_fingerprint[16]; // = {0x77,0x1E,0x7E,0xF4,0x0B,0x57,0x2D,0x2B,0xFA,0xB1,0x2C,0x49,0x54,0x7A,0xDC,0xBF};


  virtual ~Aim_instanceDisk_presult() throw();
  RimpException re;

  _Aim_instanceDisk_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Aim_instanceDisk_presult& obj);
};

typedef struct _Aim_renameDisk_args__isset {
  _Aim_renameDisk_args__isset() : oldPath(false), newPath(false) {}
  bool oldPath :1;
  bool newPath :1;
} _Aim_renameDisk_args__isset;

class Aim_renameDisk_args {
 public:

  static const char* ascii_fingerprint; // = "07A9615F837F7D0A952B595DD3020972";
  static const uint8_t binary_fingerprint[16]; // = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};

  Aim_renameDisk_args(const Aim_renameDisk_args&);
  Aim_renameDisk_args& operator=(const Aim_renameDisk_args&);
  Aim_renameDisk_args() : oldPath(), newPath() {
  }

  virtual ~Aim_renameDisk_args() throw();
  std::string oldPath;
  std::string newPath;

  _Aim_renameDisk_args__isset __isset;

  void __set_oldPath(const std::string& val);

  void __set_newPath(const std::string& val);

  bool operator == (const Aim_renameDisk_args & rhs) const
  {
    if (!(oldPath == rhs.oldPath))
      return false;
    if (!(newPath == rhs.newPath))
      return false;
    return true;
  }
  bool operator != (const Aim_renameDisk_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_renameDisk_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_renameDisk_args& obj);
};


class Aim_renameDisk_pargs {
 public:

  static const char* ascii_fingerprint; // = "07A9615F837F7D0A952B595DD3020972";
  static const uint8_t binary_fingerprint[16]; // = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};


  virtual ~Aim_renameDisk_pargs() throw();
  const std::string* oldPath;
  const std::string* newPath;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_renameDisk_pargs& obj);
};

typedef struct _Aim_renameDisk_result__isset {
  _Aim_renameDisk_result__isset() : re(false) {}
  bool re :1;
} _Aim_renameDisk_result__isset;

class Aim_renameDisk_result {
 public:

  static const char* ascii_fingerprint; // = "771E7EF40B572D2BFAB12C49547ADCBF";
  static const uint8_t binary_fingerprint[16]; // = {0x77,0x1E,0x7E,0xF4,0x0B,0x57,0x2D,0x2B,0xFA,0xB1,0x2C,0x49,0x54,0x7A,0xDC,0xBF};

  Aim_renameDisk_result(const Aim_renameDisk_result&);
  Aim_renameDisk_result& operator=(const Aim_renameDisk_result&);
  Aim_renameDisk_result() {
  }

  virtual ~Aim_renameDisk_result() throw();
  RimpException re;

  _Aim_renameDisk_result__isset __isset;

  void __set_re(const RimpException& val);

  bool operator == (const Aim_renameDisk_result & rhs) const
  {
    if (!(re == rhs.re))
      return false;
    return true;
  }
  bool operator != (const Aim_renameDisk_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_renameDisk_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_renameDisk_result& obj);
};

typedef struct _Aim_renameDisk_presult__isset {
  _Aim_renameDisk_presult__isset() : re(false) {}
  bool re :1;
} _Aim_renameDisk_presult__isset;

class Aim_renameDisk_presult {
 public:

  static const char* ascii_fingerprint; // = "771E7EF40B572D2BFAB12C49547ADCBF";
  static const uint8_t binary_fingerprint[16]; // = {0x77,0x1E,0x7E,0xF4,0x0B,0x57,0x2D,0x2B,0xFA,0xB1,0x2C,0x49,0x54,0x7A,0xDC,0xBF};


  virtual ~Aim_renameDisk_presult() throw();
  RimpException re;

  _Aim_renameDisk_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Aim_renameDisk_presult& obj);
};

typedef struct _Aim_createVLAN_args__isset {
  _Aim_createVLAN_args__isset() : vlanTag(false), vlanInterface(false), bridgeInterface(false) {}
  bool vlanTag :1;
  bool vlanInterface :1;
  bool bridgeInterface :1;
} _Aim_createVLAN_args__isset;

class Aim_createVLAN_args {
 public:

  static const char* ascii_fingerprint; // = "3368C2F81F2FEF71F11EDACDB2A3ECEF";
  static const uint8_t binary_fingerprint[16]; // = {0x33,0x68,0xC2,0xF8,0x1F,0x2F,0xEF,0x71,0xF1,0x1E,0xDA,0xCD,0xB2,0xA3,0xEC,0xEF};

  Aim_createVLAN_args(const Aim_createVLAN_args&);
  Aim_createVLAN_args& operator=(const Aim_createVLAN_args&);
  Aim_createVLAN_args() : vlanTag(0), vlanInterface(), bridgeInterface() {
  }

  virtual ~Aim_createVLAN_args() throw();
  int32_t vlanTag;
  std::string vlanInterface;
  std::string bridgeInterface;

  _Aim_createVLAN_args__isset __isset;

  void __set_vlanTag(const int32_t val);

  void __set_vlanInterface(const std::string& val);

  void __set_bridgeInterface(const std::string& val);

  bool operator == (const Aim_createVLAN_args & rhs) const
  {
    if (!(vlanTag == rhs.vlanTag))
      return false;
    if (!(vlanInterface == rhs.vlanInterface))
      return false;
    if (!(bridgeInterface == rhs.bridgeInterface))
      return false;
    return true;
  }
  bool operator != (const Aim_createVLAN_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_createVLAN_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_createVLAN_args& obj);
};


class Aim_createVLAN_pargs {
 public:

  static const char* ascii_fingerprint; // = "3368C2F81F2FEF71F11EDACDB2A3ECEF";
  static const uint8_t binary_fingerprint[16]; // = {0x33,0x68,0xC2,0xF8,0x1F,0x2F,0xEF,0x71,0xF1,0x1E,0xDA,0xCD,0xB2,0xA3,0xEC,0xEF};


  virtual ~Aim_createVLAN_pargs() throw();
  const int32_t* vlanTag;
  const std::string* vlanInterface;
  const std::string* bridgeInterface;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_createVLAN_pargs& obj);
};

typedef struct _Aim_createVLAN_result__isset {
  _Aim_createVLAN_result__isset() : ve(false) {}
  bool ve :1;
} _Aim_createVLAN_result__isset;

class Aim_createVLAN_result {
 public:

  static const char* ascii_fingerprint; // = "771E7EF40B572D2BFAB12C49547ADCBF";
  static const uint8_t binary_fingerprint[16]; // = {0x77,0x1E,0x7E,0xF4,0x0B,0x57,0x2D,0x2B,0xFA,0xB1,0x2C,0x49,0x54,0x7A,0xDC,0xBF};

  Aim_createVLAN_result(const Aim_createVLAN_result&);
  Aim_createVLAN_result& operator=(const Aim_createVLAN_result&);
  Aim_createVLAN_result() {
  }

  virtual ~Aim_createVLAN_result() throw();
  VLanException ve;

  _Aim_createVLAN_result__isset __isset;

  void __set_ve(const VLanException& val);

  bool operator == (const Aim_createVLAN_result & rhs) const
  {
    if (!(ve == rhs.ve))
      return false;
    return true;
  }
  bool operator != (const Aim_createVLAN_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_createVLAN_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_createVLAN_result& obj);
};

typedef struct _Aim_createVLAN_presult__isset {
  _Aim_createVLAN_presult__isset() : ve(false) {}
  bool ve :1;
} _Aim_createVLAN_presult__isset;

class Aim_createVLAN_presult {
 public:

  static const char* ascii_fingerprint; // = "771E7EF40B572D2BFAB12C49547ADCBF";
  static const uint8_t binary_fingerprint[16]; // = {0x77,0x1E,0x7E,0xF4,0x0B,0x57,0x2D,0x2B,0xFA,0xB1,0x2C,0x49,0x54,0x7A,0xDC,0xBF};


  virtual ~Aim_createVLAN_presult() throw();
  VLanException ve;

  _Aim_createVLAN_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Aim_createVLAN_presult& obj);
};

typedef struct _Aim_deleteVLAN_args__isset {
  _Aim_deleteVLAN_args__isset() : vlanTag(false), vlanInterface(false), bridgeInterface(false) {}
  bool vlanTag :1;
  bool vlanInterface :1;
  bool bridgeInterface :1;
} _Aim_deleteVLAN_args__isset;

class Aim_deleteVLAN_args {
 public:

  static const char* ascii_fingerprint; // = "3368C2F81F2FEF71F11EDACDB2A3ECEF";
  static const uint8_t binary_fingerprint[16]; // = {0x33,0x68,0xC2,0xF8,0x1F,0x2F,0xEF,0x71,0xF1,0x1E,0xDA,0xCD,0xB2,0xA3,0xEC,0xEF};

  Aim_deleteVLAN_args(const Aim_deleteVLAN_args&);
  Aim_deleteVLAN_args& operator=(const Aim_deleteVLAN_args&);
  Aim_deleteVLAN_args() : vlanTag(0), vlanInterface(), bridgeInterface() {
  }

  virtual ~Aim_deleteVLAN_args() throw();
  int32_t vlanTag;
  std::string vlanInterface;
  std::string bridgeInterface;

  _Aim_deleteVLAN_args__isset __isset;

  void __set_vlanTag(const int32_t val);

  void __set_vlanInterface(const std::string& val);

  void __set_bridgeInterface(const std::string& val);

  bool operator == (const Aim_deleteVLAN_args & rhs) const
  {
    if (!(vlanTag == rhs.vlanTag))
      return false;
    if (!(vlanInterface == rhs.vlanInterface))
      return false;
    if (!(bridgeInterface == rhs.bridgeInterface))
      return false;
    return true;
  }
  bool operator != (const Aim_deleteVLAN_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_deleteVLAN_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_deleteVLAN_args& obj);
};


class Aim_deleteVLAN_pargs {
 public:

  static const char* ascii_fingerprint; // = "3368C2F81F2FEF71F11EDACDB2A3ECEF";
  static const uint8_t binary_fingerprint[16]; // = {0x33,0x68,0xC2,0xF8,0x1F,0x2F,0xEF,0x71,0xF1,0x1E,0xDA,0xCD,0xB2,0xA3,0xEC,0xEF};


  virtual ~Aim_deleteVLAN_pargs() throw();
  const int32_t* vlanTag;
  const std::string* vlanInterface;
  const std::string* bridgeInterface;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_deleteVLAN_pargs& obj);
};

typedef struct _Aim_deleteVLAN_result__isset {
  _Aim_deleteVLAN_result__isset() : ve(false) {}
  bool ve :1;
} _Aim_deleteVLAN_result__isset;

class Aim_deleteVLAN_result {
 public:

  static const char* ascii_fingerprint; // = "771E7EF40B572D2BFAB12C49547ADCBF";
  static const uint8_t binary_fingerprint[16]; // = {0x77,0x1E,0x7E,0xF4,0x0B,0x57,0x2D,0x2B,0xFA,0xB1,0x2C,0x49,0x54,0x7A,0xDC,0xBF};

  Aim_deleteVLAN_result(const Aim_deleteVLAN_result&);
  Aim_deleteVLAN_result& operator=(const Aim_deleteVLAN_result&);
  Aim_deleteVLAN_result() {
  }

  virtual ~Aim_deleteVLAN_result() throw();
  VLanException ve;

  _Aim_deleteVLAN_result__isset __isset;

  void __set_ve(const VLanException& val);

  bool operator == (const Aim_deleteVLAN_result & rhs) const
  {
    if (!(ve == rhs.ve))
      return false;
    return true;
  }
  bool operator != (const Aim_deleteVLAN_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_deleteVLAN_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_deleteVLAN_result& obj);
};

typedef struct _Aim_deleteVLAN_presult__isset {
  _Aim_deleteVLAN_presult__isset() : ve(false) {}
  bool ve :1;
} _Aim_deleteVLAN_presult__isset;

class Aim_deleteVLAN_presult {
 public:

  static const char* ascii_fingerprint; // = "771E7EF40B572D2BFAB12C49547ADCBF";
  static const uint8_t binary_fingerprint[16]; // = {0x77,0x1E,0x7E,0xF4,0x0B,0x57,0x2D,0x2B,0xFA,0xB1,0x2C,0x49,0x54,0x7A,0xDC,0xBF};


  virtual ~Aim_deleteVLAN_presult() throw();
  VLanException ve;

  _Aim_deleteVLAN_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Aim_deleteVLAN_presult& obj);
};


class Aim_checkVLANConfiguration_args {
 public:

  static const char* ascii_fingerprint; // = "99914B932BD37A50B983C5E7C90AE93B";
  static const uint8_t binary_fingerprint[16]; // = {0x99,0x91,0x4B,0x93,0x2B,0xD3,0x7A,0x50,0xB9,0x83,0xC5,0xE7,0xC9,0x0A,0xE9,0x3B};

  Aim_checkVLANConfiguration_args(const Aim_checkVLANConfiguration_args&);
  Aim_checkVLANConfiguration_args& operator=(const Aim_checkVLANConfiguration_args&);
  Aim_checkVLANConfiguration_args() {
  }

  virtual ~Aim_checkVLANConfiguration_args() throw();

  bool operator == (const Aim_checkVLANConfiguration_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Aim_checkVLANConfiguration_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_checkVLANConfiguration_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_checkVLANConfiguration_args& obj);
};


class Aim_checkVLANConfiguration_pargs {
 public:

  static const char* ascii_fingerprint; // = "99914B932BD37A50B983C5E7C90AE93B";
  static const uint8_t binary_fingerprint[16]; // = {0x99,0x91,0x4B,0x93,0x2B,0xD3,0x7A,0x50,0xB9,0x83,0xC5,0xE7,0xC9,0x0A,0xE9,0x3B};


  virtual ~Aim_checkVLANConfiguration_pargs() throw();

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_checkVLANConfiguration_pargs& obj);
};

typedef struct _Aim_checkVLANConfiguration_result__isset {
  _Aim_checkVLANConfiguration_result__isset() : ve(false) {}
  bool ve :1;
} _Aim_checkVLANConfiguration_result__isset;

class Aim_checkVLANConfiguration_result {
 public:

  static const char* ascii_fingerprint; // = "771E7EF40B572D2BFAB12C49547ADCBF";
  static const uint8_t binary_fingerprint[16]; // = {0x77,0x1E,0x7E,0xF4,0x0B,0x57,0x2D,0x2B,0xFA,0xB1,0x2C,0x49,0x54,0x7A,0xDC,0xBF};

  Aim_checkVLANConfiguration_result(const Aim_checkVLANConfiguration_result&);
  Aim_checkVLANConfiguration_result& operator=(const Aim_checkVLANConfiguration_result&);
  Aim_checkVLANConfiguration_result() {
  }

  virtual ~Aim_checkVLANConfiguration_result() throw();
  VLanException ve;

  _Aim_checkVLANConfiguration_result__isset __isset;

  void __set_ve(const VLanException& val);

  bool operator == (const Aim_checkVLANConfiguration_result & rhs) const
  {
    if (!(ve == rhs.ve))
      return false;
    return true;
  }
  bool operator != (const Aim_checkVLANConfiguration_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_checkVLANConfiguration_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_checkVLANConfiguration_result& obj);
};

typedef struct _Aim_checkVLANConfiguration_presult__isset {
  _Aim_checkVLANConfiguration_presult__isset() : ve(false) {}
  bool ve :1;
} _Aim_checkVLANConfiguration_presult__isset;

class Aim_checkVLANConfiguration_presult {
 public:

  static const char* ascii_fingerprint; // = "771E7EF40B572D2BFAB12C49547ADCBF";
  static const uint8_t binary_fingerprint[16]; // = {0x77,0x1E,0x7E,0xF4,0x0B,0x57,0x2D,0x2B,0xFA,0xB1,0x2C,0x49,0x54,0x7A,0xDC,0xBF};


  virtual ~Aim_checkVLANConfiguration_presult() throw();
  VLanException ve;

  _Aim_checkVLANConfiguration_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Aim_checkVLANConfiguration_presult& obj);
};


class Aim_getInitiatorIQN_args {
 public:

  static const char* ascii_fingerprint; // = "99914B932BD37A50B983C5E7C90AE93B";
  static const uint8_t binary_fingerprint[16]; // = {0x99,0x91,0x4B,0x93,0x2B,0xD3,0x7A,0x50,0xB9,0x83,0xC5,0xE7,0xC9,0x0A,0xE9,0x3B};

  Aim_getInitiatorIQN_args(const Aim_getInitiatorIQN_args&);
  Aim_getInitiatorIQN_args& operator=(const Aim_getInitiatorIQN_args&);
  Aim_getInitiatorIQN_args() {
  }

  virtual ~Aim_getInitiatorIQN_args() throw();

  bool operator == (const Aim_getInitiatorIQN_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Aim_getInitiatorIQN_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_getInitiatorIQN_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_getInitiatorIQN_args& obj);
};


class Aim_getInitiatorIQN_pargs {
 public:

  static const char* ascii_fingerprint; // = "99914B932BD37A50B983C5E7C90AE93B";
  static const uint8_t binary_fingerprint[16]; // = {0x99,0x91,0x4B,0x93,0x2B,0xD3,0x7A,0x50,0xB9,0x83,0xC5,0xE7,0xC9,0x0A,0xE9,0x3B};


  virtual ~Aim_getInitiatorIQN_pargs() throw();

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_getInitiatorIQN_pargs& obj);
};

typedef struct _Aim_getInitiatorIQN_result__isset {
  _Aim_getInitiatorIQN_result__isset() : success(false), se(false) {}
  bool success :1;
  bool se :1;
} _Aim_getInitiatorIQN_result__isset;

class Aim_getInitiatorIQN_result {
 public:

  static const char* ascii_fingerprint; // = "FB3D66E547AE5D7F8EB046D752ECF5C1";
  static const uint8_t binary_fingerprint[16]; // = {0xFB,0x3D,0x66,0xE5,0x47,0xAE,0x5D,0x7F,0x8E,0xB0,0x46,0xD7,0x52,0xEC,0xF5,0xC1};

  Aim_getInitiatorIQN_result(const Aim_getInitiatorIQN_result&);
  Aim_getInitiatorIQN_result& operator=(const Aim_getInitiatorIQN_result&);
  Aim_getInitiatorIQN_result() : success() {
  }

  virtual ~Aim_getInitiatorIQN_result() throw();
  std::string success;
  StorageException se;

  _Aim_getInitiatorIQN_result__isset __isset;

  void __set_success(const std::string& val);

  void __set_se(const StorageException& val);

  bool operator == (const Aim_getInitiatorIQN_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(se == rhs.se))
      return false;
    return true;
  }
  bool operator != (const Aim_getInitiatorIQN_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_getInitiatorIQN_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_getInitiatorIQN_result& obj);
};

typedef struct _Aim_getInitiatorIQN_presult__isset {
  _Aim_getInitiatorIQN_presult__isset() : success(false), se(false) {}
  bool success :1;
  bool se :1;
} _Aim_getInitiatorIQN_presult__isset;

class Aim_getInitiatorIQN_presult {
 public:

  static const char* ascii_fingerprint; // = "FB3D66E547AE5D7F8EB046D752ECF5C1";
  static const uint8_t binary_fingerprint[16]; // = {0xFB,0x3D,0x66,0xE5,0x47,0xAE,0x5D,0x7F,0x8E,0xB0,0x46,0xD7,0x52,0xEC,0xF5,0xC1};


  virtual ~Aim_getInitiatorIQN_presult() throw();
  std::string* success;
  StorageException se;

  _Aim_getInitiatorIQN_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Aim_getInitiatorIQN_presult& obj);
};

typedef struct _Aim_rescanISCSI_args__isset {
  _Aim_rescanISCSI_args__isset() : targets(false) {}
  bool targets :1;
} _Aim_rescanISCSI_args__isset;

class Aim_rescanISCSI_args {
 public:

  static const char* ascii_fingerprint; // = "ACE4F644F0FDD289DDC4EE5B83BC13C0";
  static const uint8_t binary_fingerprint[16]; // = {0xAC,0xE4,0xF6,0x44,0xF0,0xFD,0xD2,0x89,0xDD,0xC4,0xEE,0x5B,0x83,0xBC,0x13,0xC0};

  Aim_rescanISCSI_args(const Aim_rescanISCSI_args&);
  Aim_rescanISCSI_args& operator=(const Aim_rescanISCSI_args&);
  Aim_rescanISCSI_args() {
  }

  virtual ~Aim_rescanISCSI_args() throw();
  std::vector<std::string>  targets;

  _Aim_rescanISCSI_args__isset __isset;

  void __set_targets(const std::vector<std::string> & val);

  bool operator == (const Aim_rescanISCSI_args & rhs) const
  {
    if (!(targets == rhs.targets))
      return false;
    return true;
  }
  bool operator != (const Aim_rescanISCSI_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_rescanISCSI_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_rescanISCSI_args& obj);
};


class Aim_rescanISCSI_pargs {
 public:

  static const char* ascii_fingerprint; // = "ACE4F644F0FDD289DDC4EE5B83BC13C0";
  static const uint8_t binary_fingerprint[16]; // = {0xAC,0xE4,0xF6,0x44,0xF0,0xFD,0xD2,0x89,0xDD,0xC4,0xEE,0x5B,0x83,0xBC,0x13,0xC0};


  virtual ~Aim_rescanISCSI_pargs() throw();
  const std::vector<std::string> * targets;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_rescanISCSI_pargs& obj);
};

typedef struct _Aim_rescanISCSI_result__isset {
  _Aim_rescanISCSI_result__isset() : se(false) {}
  bool se :1;
} _Aim_rescanISCSI_result__isset;

class Aim_rescanISCSI_result {
 public:

  static const char* ascii_fingerprint; // = "771E7EF40B572D2BFAB12C49547ADCBF";
  static const uint8_t binary_fingerprint[16]; // = {0x77,0x1E,0x7E,0xF4,0x0B,0x57,0x2D,0x2B,0xFA,0xB1,0x2C,0x49,0x54,0x7A,0xDC,0xBF};

  Aim_rescanISCSI_result(const Aim_rescanISCSI_result&);
  Aim_rescanISCSI_result& operator=(const Aim_rescanISCSI_result&);
  Aim_rescanISCSI_result() {
  }

  virtual ~Aim_rescanISCSI_result() throw();
  StorageException se;

  _Aim_rescanISCSI_result__isset __isset;

  void __set_se(const StorageException& val);

  bool operator == (const Aim_rescanISCSI_result & rhs) const
  {
    if (!(se == rhs.se))
      return false;
    return true;
  }
  bool operator != (const Aim_rescanISCSI_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_rescanISCSI_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_rescanISCSI_result& obj);
};

typedef struct _Aim_rescanISCSI_presult__isset {
  _Aim_rescanISCSI_presult__isset() : se(false) {}
  bool se :1;
} _Aim_rescanISCSI_presult__isset;

class Aim_rescanISCSI_presult {
 public:

  static const char* ascii_fingerprint; // = "771E7EF40B572D2BFAB12C49547ADCBF";
  static const uint8_t binary_fingerprint[16]; // = {0x77,0x1E,0x7E,0xF4,0x0B,0x57,0x2D,0x2B,0xFA,0xB1,0x2C,0x49,0x54,0x7A,0xDC,0xBF};


  virtual ~Aim_rescanISCSI_presult() throw();
  StorageException se;

  _Aim_rescanISCSI_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Aim_rescanISCSI_presult& obj);
};


class Aim_getNodeInfo_args {
 public:

  static const char* ascii_fingerprint; // = "99914B932BD37A50B983C5E7C90AE93B";
  static const uint8_t binary_fingerprint[16]; // = {0x99,0x91,0x4B,0x93,0x2B,0xD3,0x7A,0x50,0xB9,0x83,0xC5,0xE7,0xC9,0x0A,0xE9,0x3B};

  Aim_getNodeInfo_args(const Aim_getNodeInfo_args&);
  Aim_getNodeInfo_args& operator=(const Aim_getNodeInfo_args&);
  Aim_getNodeInfo_args() {
  }

  virtual ~Aim_getNodeInfo_args() throw();

  bool operator == (const Aim_getNodeInfo_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Aim_getNodeInfo_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_getNodeInfo_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_getNodeInfo_args& obj);
};


class Aim_getNodeInfo_pargs {
 public:

  static const char* ascii_fingerprint; // = "99914B932BD37A50B983C5E7C90AE93B";
  static const uint8_t binary_fingerprint[16]; // = {0x99,0x91,0x4B,0x93,0x2B,0xD3,0x7A,0x50,0xB9,0x83,0xC5,0xE7,0xC9,0x0A,0xE9,0x3B};


  virtual ~Aim_getNodeInfo_pargs() throw();

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_getNodeInfo_pargs& obj);
};

typedef struct _Aim_getNodeInfo_result__isset {
  _Aim_getNodeInfo_result__isset() : success(false), libvirtException(false) {}
  bool success :1;
  bool libvirtException :1;
} _Aim_getNodeInfo_result__isset;

class Aim_getNodeInfo_result {
 public:

  static const char* ascii_fingerprint; // = "B674B36A2EA45332B31BE3B5BD5259C3";
  static const uint8_t binary_fingerprint[16]; // = {0xB6,0x74,0xB3,0x6A,0x2E,0xA4,0x53,0x32,0xB3,0x1B,0xE3,0xB5,0xBD,0x52,0x59,0xC3};

  Aim_getNodeInfo_result(const Aim_getNodeInfo_result&);
  Aim_getNodeInfo_result& operator=(const Aim_getNodeInfo_result&);
  Aim_getNodeInfo_result() {
  }

  virtual ~Aim_getNodeInfo_result() throw();
  NodeInfo success;
  LibvirtException libvirtException;

  _Aim_getNodeInfo_result__isset __isset;

  void __set_success(const NodeInfo& val);

  void __set_libvirtException(const LibvirtException& val);

  bool operator == (const Aim_getNodeInfo_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(libvirtException == rhs.libvirtException))
      return false;
    return true;
  }
  bool operator != (const Aim_getNodeInfo_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_getNodeInfo_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_getNodeInfo_result& obj);
};

typedef struct _Aim_getNodeInfo_presult__isset {
  _Aim_getNodeInfo_presult__isset() : success(false), libvirtException(false) {}
  bool success :1;
  bool libvirtException :1;
} _Aim_getNodeInfo_presult__isset;

class Aim_getNodeInfo_presult {
 public:

  static const char* ascii_fingerprint; // = "B674B36A2EA45332B31BE3B5BD5259C3";
  static const uint8_t binary_fingerprint[16]; // = {0xB6,0x74,0xB3,0x6A,0x2E,0xA4,0x53,0x32,0xB3,0x1B,0xE3,0xB5,0xBD,0x52,0x59,0xC3};


  virtual ~Aim_getNodeInfo_presult() throw();
  NodeInfo* success;
  LibvirtException libvirtException;

  _Aim_getNodeInfo_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Aim_getNodeInfo_presult& obj);
};

typedef struct _Aim_defineDomain_args__isset {
  _Aim_defineDomain_args__isset() : xmlDesc(false) {}
  bool xmlDesc :1;
} _Aim_defineDomain_args__isset;

class Aim_defineDomain_args {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  Aim_defineDomain_args(const Aim_defineDomain_args&);
  Aim_defineDomain_args& operator=(const Aim_defineDomain_args&);
  Aim_defineDomain_args() : xmlDesc() {
  }

  virtual ~Aim_defineDomain_args() throw();
  std::string xmlDesc;

  _Aim_defineDomain_args__isset __isset;

  void __set_xmlDesc(const std::string& val);

  bool operator == (const Aim_defineDomain_args & rhs) const
  {
    if (!(xmlDesc == rhs.xmlDesc))
      return false;
    return true;
  }
  bool operator != (const Aim_defineDomain_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_defineDomain_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_defineDomain_args& obj);
};


class Aim_defineDomain_pargs {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};


  virtual ~Aim_defineDomain_pargs() throw();
  const std::string* xmlDesc;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_defineDomain_pargs& obj);
};

typedef struct _Aim_defineDomain_result__isset {
  _Aim_defineDomain_result__isset() : libvirtException(false) {}
  bool libvirtException :1;
} _Aim_defineDomain_result__isset;

class Aim_defineDomain_result {
 public:

  static const char* ascii_fingerprint; // = "EAF4C873F89672ABB97ED74219F64E64";
  static const uint8_t binary_fingerprint[16]; // = {0xEA,0xF4,0xC8,0x73,0xF8,0x96,0x72,0xAB,0xB9,0x7E,0xD7,0x42,0x19,0xF6,0x4E,0x64};

  Aim_defineDomain_result(const Aim_defineDomain_result&);
  Aim_defineDomain_result& operator=(const Aim_defineDomain_result&);
  Aim_defineDomain_result() {
  }

  virtual ~Aim_defineDomain_result() throw();
  LibvirtException libvirtException;

  _Aim_defineDomain_result__isset __isset;

  void __set_libvirtException(const LibvirtException& val);

  bool operator == (const Aim_defineDomain_result & rhs) const
  {
    if (!(libvirtException == rhs.libvirtException))
      return false;
    return true;
  }
  bool operator != (const Aim_defineDomain_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_defineDomain_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_defineDomain_result& obj);
};

typedef struct _Aim_defineDomain_presult__isset {
  _Aim_defineDomain_presult__isset() : libvirtException(false) {}
  bool libvirtException :1;
} _Aim_defineDomain_presult__isset;

class Aim_defineDomain_presult {
 public:

  static const char* ascii_fingerprint; // = "EAF4C873F89672ABB97ED74219F64E64";
  static const uint8_t binary_fingerprint[16]; // = {0xEA,0xF4,0xC8,0x73,0xF8,0x96,0x72,0xAB,0xB9,0x7E,0xD7,0x42,0x19,0xF6,0x4E,0x64};


  virtual ~Aim_defineDomain_presult() throw();
  LibvirtException libvirtException;

  _Aim_defineDomain_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Aim_defineDomain_presult& obj);
};

typedef struct _Aim_undefineDomain_args__isset {
  _Aim_undefineDomain_args__isset() : domainName(false) {}
  bool domainName :1;
} _Aim_undefineDomain_args__isset;

class Aim_undefineDomain_args {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  Aim_undefineDomain_args(const Aim_undefineDomain_args&);
  Aim_undefineDomain_args& operator=(const Aim_undefineDomain_args&);
  Aim_undefineDomain_args() : domainName() {
  }

  virtual ~Aim_undefineDomain_args() throw();
  std::string domainName;

  _Aim_undefineDomain_args__isset __isset;

  void __set_domainName(const std::string& val);

  bool operator == (const Aim_undefineDomain_args & rhs) const
  {
    if (!(domainName == rhs.domainName))
      return false;
    return true;
  }
  bool operator != (const Aim_undefineDomain_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_undefineDomain_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_undefineDomain_args& obj);
};


class Aim_undefineDomain_pargs {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};


  virtual ~Aim_undefineDomain_pargs() throw();
  const std::string* domainName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_undefineDomain_pargs& obj);
};

typedef struct _Aim_undefineDomain_result__isset {
  _Aim_undefineDomain_result__isset() : libvirtException(false) {}
  bool libvirtException :1;
} _Aim_undefineDomain_result__isset;

class Aim_undefineDomain_result {
 public:

  static const char* ascii_fingerprint; // = "EAF4C873F89672ABB97ED74219F64E64";
  static const uint8_t binary_fingerprint[16]; // = {0xEA,0xF4,0xC8,0x73,0xF8,0x96,0x72,0xAB,0xB9,0x7E,0xD7,0x42,0x19,0xF6,0x4E,0x64};

  Aim_undefineDomain_result(const Aim_undefineDomain_result&);
  Aim_undefineDomain_result& operator=(const Aim_undefineDomain_result&);
  Aim_undefineDomain_result() {
  }

  virtual ~Aim_undefineDomain_result() throw();
  LibvirtException libvirtException;

  _Aim_undefineDomain_result__isset __isset;

  void __set_libvirtException(const LibvirtException& val);

  bool operator == (const Aim_undefineDomain_result & rhs) const
  {
    if (!(libvirtException == rhs.libvirtException))
      return false;
    return true;
  }
  bool operator != (const Aim_undefineDomain_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_undefineDomain_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_undefineDomain_result& obj);
};

typedef struct _Aim_undefineDomain_presult__isset {
  _Aim_undefineDomain_presult__isset() : libvirtException(false) {}
  bool libvirtException :1;
} _Aim_undefineDomain_presult__isset;

class Aim_undefineDomain_presult {
 public:

  static const char* ascii_fingerprint; // = "EAF4C873F89672ABB97ED74219F64E64";
  static const uint8_t binary_fingerprint[16]; // = {0xEA,0xF4,0xC8,0x73,0xF8,0x96,0x72,0xAB,0xB9,0x7E,0xD7,0x42,0x19,0xF6,0x4E,0x64};


  virtual ~Aim_undefineDomain_presult() throw();
  LibvirtException libvirtException;

  _Aim_undefineDomain_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Aim_undefineDomain_presult& obj);
};

typedef struct _Aim_existDomain_args__isset {
  _Aim_existDomain_args__isset() : domainName(false) {}
  bool domainName :1;
} _Aim_existDomain_args__isset;

class Aim_existDomain_args {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  Aim_existDomain_args(const Aim_existDomain_args&);
  Aim_existDomain_args& operator=(const Aim_existDomain_args&);
  Aim_existDomain_args() : domainName() {
  }

  virtual ~Aim_existDomain_args() throw();
  std::string domainName;

  _Aim_existDomain_args__isset __isset;

  void __set_domainName(const std::string& val);

  bool operator == (const Aim_existDomain_args & rhs) const
  {
    if (!(domainName == rhs.domainName))
      return false;
    return true;
  }
  bool operator != (const Aim_existDomain_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_existDomain_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_existDomain_args& obj);
};


class Aim_existDomain_pargs {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};


  virtual ~Aim_existDomain_pargs() throw();
  const std::string* domainName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_existDomain_pargs& obj);
};

typedef struct _Aim_existDomain_result__isset {
  _Aim_existDomain_result__isset() : success(false) {}
  bool success :1;
} _Aim_existDomain_result__isset;

class Aim_existDomain_result {
 public:

  static const char* ascii_fingerprint; // = "D9D3B4421B1F23CB4063C80B484E7909";
  static const uint8_t binary_fingerprint[16]; // = {0xD9,0xD3,0xB4,0x42,0x1B,0x1F,0x23,0xCB,0x40,0x63,0xC8,0x0B,0x48,0x4E,0x79,0x09};

  Aim_existDomain_result(const Aim_existDomain_result&);
  Aim_existDomain_result& operator=(const Aim_existDomain_result&);
  Aim_existDomain_result() : success(0) {
  }

  virtual ~Aim_existDomain_result() throw();
  bool success;

  _Aim_existDomain_result__isset __isset;

  void __set_success(const bool val);

  bool operator == (const Aim_existDomain_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Aim_existDomain_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_existDomain_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_existDomain_result& obj);
};

typedef struct _Aim_existDomain_presult__isset {
  _Aim_existDomain_presult__isset() : success(false) {}
  bool success :1;
} _Aim_existDomain_presult__isset;

class Aim_existDomain_presult {
 public:

  static const char* ascii_fingerprint; // = "D9D3B4421B1F23CB4063C80B484E7909";
  static const uint8_t binary_fingerprint[16]; // = {0xD9,0xD3,0xB4,0x42,0x1B,0x1F,0x23,0xCB,0x40,0x63,0xC8,0x0B,0x48,0x4E,0x79,0x09};


  virtual ~Aim_existDomain_presult() throw();
  bool* success;

  _Aim_existDomain_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Aim_existDomain_presult& obj);
};

typedef struct _Aim_getDomainState_args__isset {
  _Aim_getDomainState_args__isset() : domainName(false) {}
  bool domainName :1;
} _Aim_getDomainState_args__isset;

class Aim_getDomainState_args {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  Aim_getDomainState_args(const Aim_getDomainState_args&);
  Aim_getDomainState_args& operator=(const Aim_getDomainState_args&);
  Aim_getDomainState_args() : domainName() {
  }

  virtual ~Aim_getDomainState_args() throw();
  std::string domainName;

  _Aim_getDomainState_args__isset __isset;

  void __set_domainName(const std::string& val);

  bool operator == (const Aim_getDomainState_args & rhs) const
  {
    if (!(domainName == rhs.domainName))
      return false;
    return true;
  }
  bool operator != (const Aim_getDomainState_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_getDomainState_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_getDomainState_args& obj);
};


class Aim_getDomainState_pargs {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};


  virtual ~Aim_getDomainState_pargs() throw();
  const std::string* domainName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_getDomainState_pargs& obj);
};

typedef struct _Aim_getDomainState_result__isset {
  _Aim_getDomainState_result__isset() : success(false), libvirtException(false) {}
  bool success :1;
  bool libvirtException :1;
} _Aim_getDomainState_result__isset;

class Aim_getDomainState_result {
 public:

  static const char* ascii_fingerprint; // = "9A6B8977E69CEEB211584938C2E15A90";
  static const uint8_t binary_fingerprint[16]; // = {0x9A,0x6B,0x89,0x77,0xE6,0x9C,0xEE,0xB2,0x11,0x58,0x49,0x38,0xC2,0xE1,0x5A,0x90};

  Aim_getDomainState_result(const Aim_getDomainState_result&);
  Aim_getDomainState_result& operator=(const Aim_getDomainState_result&);
  Aim_getDomainState_result() : success((DomainState::type)0) {
  }

  virtual ~Aim_getDomainState_result() throw();
  DomainState::type success;
  LibvirtException libvirtException;

  _Aim_getDomainState_result__isset __isset;

  void __set_success(const DomainState::type val);

  void __set_libvirtException(const LibvirtException& val);

  bool operator == (const Aim_getDomainState_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(libvirtException == rhs.libvirtException))
      return false;
    return true;
  }
  bool operator != (const Aim_getDomainState_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_getDomainState_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_getDomainState_result& obj);
};

typedef struct _Aim_getDomainState_presult__isset {
  _Aim_getDomainState_presult__isset() : success(false), libvirtException(false) {}
  bool success :1;
  bool libvirtException :1;
} _Aim_getDomainState_presult__isset;

class Aim_getDomainState_presult {
 public:

  static const char* ascii_fingerprint; // = "9A6B8977E69CEEB211584938C2E15A90";
  static const uint8_t binary_fingerprint[16]; // = {0x9A,0x6B,0x89,0x77,0xE6,0x9C,0xEE,0xB2,0x11,0x58,0x49,0x38,0xC2,0xE1,0x5A,0x90};


  virtual ~Aim_getDomainState_presult() throw();
  DomainState::type* success;
  LibvirtException libvirtException;

  _Aim_getDomainState_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Aim_getDomainState_presult& obj);
};

typedef struct _Aim_getDomainInfo_args__isset {
  _Aim_getDomainInfo_args__isset() : domainName(false) {}
  bool domainName :1;
} _Aim_getDomainInfo_args__isset;

class Aim_getDomainInfo_args {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  Aim_getDomainInfo_args(const Aim_getDomainInfo_args&);
  Aim_getDomainInfo_args& operator=(const Aim_getDomainInfo_args&);
  Aim_getDomainInfo_args() : domainName() {
  }

  virtual ~Aim_getDomainInfo_args() throw();
  std::string domainName;

  _Aim_getDomainInfo_args__isset __isset;

  void __set_domainName(const std::string& val);

  bool operator == (const Aim_getDomainInfo_args & rhs) const
  {
    if (!(domainName == rhs.domainName))
      return false;
    return true;
  }
  bool operator != (const Aim_getDomainInfo_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_getDomainInfo_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_getDomainInfo_args& obj);
};


class Aim_getDomainInfo_pargs {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};


  virtual ~Aim_getDomainInfo_pargs() throw();
  const std::string* domainName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_getDomainInfo_pargs& obj);
};

typedef struct _Aim_getDomainInfo_result__isset {
  _Aim_getDomainInfo_result__isset() : success(false), libvirtException(false) {}
  bool success :1;
  bool libvirtException :1;
} _Aim_getDomainInfo_result__isset;

class Aim_getDomainInfo_result {
 public:

  static const char* ascii_fingerprint; // = "8EF274FF0709239A970D99D8D4EA7A39";
  static const uint8_t binary_fingerprint[16]; // = {0x8E,0xF2,0x74,0xFF,0x07,0x09,0x23,0x9A,0x97,0x0D,0x99,0xD8,0xD4,0xEA,0x7A,0x39};

  Aim_getDomainInfo_result(const Aim_getDomainInfo_result&);
  Aim_getDomainInfo_result& operator=(const Aim_getDomainInfo_result&);
  Aim_getDomainInfo_result() {
  }

  virtual ~Aim_getDomainInfo_result() throw();
  DomainInfo success;
  LibvirtException libvirtException;

  _Aim_getDomainInfo_result__isset __isset;

  void __set_success(const DomainInfo& val);

  void __set_libvirtException(const LibvirtException& val);

  bool operator == (const Aim_getDomainInfo_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(libvirtException == rhs.libvirtException))
      return false;
    return true;
  }
  bool operator != (const Aim_getDomainInfo_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_getDomainInfo_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_getDomainInfo_result& obj);
};

typedef struct _Aim_getDomainInfo_presult__isset {
  _Aim_getDomainInfo_presult__isset() : success(false), libvirtException(false) {}
  bool success :1;
  bool libvirtException :1;
} _Aim_getDomainInfo_presult__isset;

class Aim_getDomainInfo_presult {
 public:

  static const char* ascii_fingerprint; // = "8EF274FF0709239A970D99D8D4EA7A39";
  static const uint8_t binary_fingerprint[16]; // = {0x8E,0xF2,0x74,0xFF,0x07,0x09,0x23,0x9A,0x97,0x0D,0x99,0xD8,0xD4,0xEA,0x7A,0x39};


  virtual ~Aim_getDomainInfo_presult() throw();
  DomainInfo* success;
  LibvirtException libvirtException;

  _Aim_getDomainInfo_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Aim_getDomainInfo_presult& obj);
};


class Aim_getDomains_args {
 public:

  static const char* ascii_fingerprint; // = "99914B932BD37A50B983C5E7C90AE93B";
  static const uint8_t binary_fingerprint[16]; // = {0x99,0x91,0x4B,0x93,0x2B,0xD3,0x7A,0x50,0xB9,0x83,0xC5,0xE7,0xC9,0x0A,0xE9,0x3B};

  Aim_getDomains_args(const Aim_getDomains_args&);
  Aim_getDomains_args& operator=(const Aim_getDomains_args&);
  Aim_getDomains_args() {
  }

  virtual ~Aim_getDomains_args() throw();

  bool operator == (const Aim_getDomains_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Aim_getDomains_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_getDomains_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_getDomains_args& obj);
};


class Aim_getDomains_pargs {
 public:

  static const char* ascii_fingerprint; // = "99914B932BD37A50B983C5E7C90AE93B";
  static const uint8_t binary_fingerprint[16]; // = {0x99,0x91,0x4B,0x93,0x2B,0xD3,0x7A,0x50,0xB9,0x83,0xC5,0xE7,0xC9,0x0A,0xE9,0x3B};


  virtual ~Aim_getDomains_pargs() throw();

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_getDomains_pargs& obj);
};

typedef struct _Aim_getDomains_result__isset {
  _Aim_getDomains_result__isset() : success(false), libvirtException(false) {}
  bool success :1;
  bool libvirtException :1;
} _Aim_getDomains_result__isset;

class Aim_getDomains_result {
 public:

  static const char* ascii_fingerprint; // = "DD2CDF872EFCB14B61F0AC637C8EA516";
  static const uint8_t binary_fingerprint[16]; // = {0xDD,0x2C,0xDF,0x87,0x2E,0xFC,0xB1,0x4B,0x61,0xF0,0xAC,0x63,0x7C,0x8E,0xA5,0x16};

  Aim_getDomains_result(const Aim_getDomains_result&);
  Aim_getDomains_result& operator=(const Aim_getDomains_result&);
  Aim_getDomains_result() {
  }

  virtual ~Aim_getDomains_result() throw();
  std::vector<DomainInfo>  success;
  LibvirtException libvirtException;

  _Aim_getDomains_result__isset __isset;

  void __set_success(const std::vector<DomainInfo> & val);

  void __set_libvirtException(const LibvirtException& val);

  bool operator == (const Aim_getDomains_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(libvirtException == rhs.libvirtException))
      return false;
    return true;
  }
  bool operator != (const Aim_getDomains_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_getDomains_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_getDomains_result& obj);
};

typedef struct _Aim_getDomains_presult__isset {
  _Aim_getDomains_presult__isset() : success(false), libvirtException(false) {}
  bool success :1;
  bool libvirtException :1;
} _Aim_getDomains_presult__isset;

class Aim_getDomains_presult {
 public:

  static const char* ascii_fingerprint; // = "DD2CDF872EFCB14B61F0AC637C8EA516";
  static const uint8_t binary_fingerprint[16]; // = {0xDD,0x2C,0xDF,0x87,0x2E,0xFC,0xB1,0x4B,0x61,0xF0,0xAC,0x63,0x7C,0x8E,0xA5,0x16};


  virtual ~Aim_getDomains_presult() throw();
  std::vector<DomainInfo> * success;
  LibvirtException libvirtException;

  _Aim_getDomains_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Aim_getDomains_presult& obj);
};

typedef struct _Aim_powerOn_args__isset {
  _Aim_powerOn_args__isset() : domainName(false) {}
  bool domainName :1;
} _Aim_powerOn_args__isset;

class Aim_powerOn_args {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  Aim_powerOn_args(const Aim_powerOn_args&);
  Aim_powerOn_args& operator=(const Aim_powerOn_args&);
  Aim_powerOn_args() : domainName() {
  }

  virtual ~Aim_powerOn_args() throw();
  std::string domainName;

  _Aim_powerOn_args__isset __isset;

  void __set_domainName(const std::string& val);

  bool operator == (const Aim_powerOn_args & rhs) const
  {
    if (!(domainName == rhs.domainName))
      return false;
    return true;
  }
  bool operator != (const Aim_powerOn_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_powerOn_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_powerOn_args& obj);
};


class Aim_powerOn_pargs {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};


  virtual ~Aim_powerOn_pargs() throw();
  const std::string* domainName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_powerOn_pargs& obj);
};

typedef struct _Aim_powerOn_result__isset {
  _Aim_powerOn_result__isset() : libvirtException(false) {}
  bool libvirtException :1;
} _Aim_powerOn_result__isset;

class Aim_powerOn_result {
 public:

  static const char* ascii_fingerprint; // = "EAF4C873F89672ABB97ED74219F64E64";
  static const uint8_t binary_fingerprint[16]; // = {0xEA,0xF4,0xC8,0x73,0xF8,0x96,0x72,0xAB,0xB9,0x7E,0xD7,0x42,0x19,0xF6,0x4E,0x64};

  Aim_powerOn_result(const Aim_powerOn_result&);
  Aim_powerOn_result& operator=(const Aim_powerOn_result&);
  Aim_powerOn_result() {
  }

  virtual ~Aim_powerOn_result() throw();
  LibvirtException libvirtException;

  _Aim_powerOn_result__isset __isset;

  void __set_libvirtException(const LibvirtException& val);

  bool operator == (const Aim_powerOn_result & rhs) const
  {
    if (!(libvirtException == rhs.libvirtException))
      return false;
    return true;
  }
  bool operator != (const Aim_powerOn_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_powerOn_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_powerOn_result& obj);
};

typedef struct _Aim_powerOn_presult__isset {
  _Aim_powerOn_presult__isset() : libvirtException(false) {}
  bool libvirtException :1;
} _Aim_powerOn_presult__isset;

class Aim_powerOn_presult {
 public:

  static const char* ascii_fingerprint; // = "EAF4C873F89672ABB97ED74219F64E64";
  static const uint8_t binary_fingerprint[16]; // = {0xEA,0xF4,0xC8,0x73,0xF8,0x96,0x72,0xAB,0xB9,0x7E,0xD7,0x42,0x19,0xF6,0x4E,0x64};


  virtual ~Aim_powerOn_presult() throw();
  LibvirtException libvirtException;

  _Aim_powerOn_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Aim_powerOn_presult& obj);
};

typedef struct _Aim_powerOff_args__isset {
  _Aim_powerOff_args__isset() : domainName(false) {}
  bool domainName :1;
} _Aim_powerOff_args__isset;

class Aim_powerOff_args {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  Aim_powerOff_args(const Aim_powerOff_args&);
  Aim_powerOff_args& operator=(const Aim_powerOff_args&);
  Aim_powerOff_args() : domainName() {
  }

  virtual ~Aim_powerOff_args() throw();
  std::string domainName;

  _Aim_powerOff_args__isset __isset;

  void __set_domainName(const std::string& val);

  bool operator == (const Aim_powerOff_args & rhs) const
  {
    if (!(domainName == rhs.domainName))
      return false;
    return true;
  }
  bool operator != (const Aim_powerOff_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_powerOff_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_powerOff_args& obj);
};


class Aim_powerOff_pargs {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};


  virtual ~Aim_powerOff_pargs() throw();
  const std::string* domainName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_powerOff_pargs& obj);
};

typedef struct _Aim_powerOff_result__isset {
  _Aim_powerOff_result__isset() : libvirtException(false) {}
  bool libvirtException :1;
} _Aim_powerOff_result__isset;

class Aim_powerOff_result {
 public:

  static const char* ascii_fingerprint; // = "EAF4C873F89672ABB97ED74219F64E64";
  static const uint8_t binary_fingerprint[16]; // = {0xEA,0xF4,0xC8,0x73,0xF8,0x96,0x72,0xAB,0xB9,0x7E,0xD7,0x42,0x19,0xF6,0x4E,0x64};

  Aim_powerOff_result(const Aim_powerOff_result&);
  Aim_powerOff_result& operator=(const Aim_powerOff_result&);
  Aim_powerOff_result() {
  }

  virtual ~Aim_powerOff_result() throw();
  LibvirtException libvirtException;

  _Aim_powerOff_result__isset __isset;

  void __set_libvirtException(const LibvirtException& val);

  bool operator == (const Aim_powerOff_result & rhs) const
  {
    if (!(libvirtException == rhs.libvirtException))
      return false;
    return true;
  }
  bool operator != (const Aim_powerOff_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_powerOff_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_powerOff_result& obj);
};

typedef struct _Aim_powerOff_presult__isset {
  _Aim_powerOff_presult__isset() : libvirtException(false) {}
  bool libvirtException :1;
} _Aim_powerOff_presult__isset;

class Aim_powerOff_presult {
 public:

  static const char* ascii_fingerprint; // = "EAF4C873F89672ABB97ED74219F64E64";
  static const uint8_t binary_fingerprint[16]; // = {0xEA,0xF4,0xC8,0x73,0xF8,0x96,0x72,0xAB,0xB9,0x7E,0xD7,0x42,0x19,0xF6,0x4E,0x64};


  virtual ~Aim_powerOff_presult() throw();
  LibvirtException libvirtException;

  _Aim_powerOff_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Aim_powerOff_presult& obj);
};

typedef struct _Aim_shutdown_args__isset {
  _Aim_shutdown_args__isset() : domainName(false) {}
  bool domainName :1;
} _Aim_shutdown_args__isset;

class Aim_shutdown_args {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  Aim_shutdown_args(const Aim_shutdown_args&);
  Aim_shutdown_args& operator=(const Aim_shutdown_args&);
  Aim_shutdown_args() : domainName() {
  }

  virtual ~Aim_shutdown_args() throw();
  std::string domainName;

  _Aim_shutdown_args__isset __isset;

  void __set_domainName(const std::string& val);

  bool operator == (const Aim_shutdown_args & rhs) const
  {
    if (!(domainName == rhs.domainName))
      return false;
    return true;
  }
  bool operator != (const Aim_shutdown_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_shutdown_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_shutdown_args& obj);
};


class Aim_shutdown_pargs {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};


  virtual ~Aim_shutdown_pargs() throw();
  const std::string* domainName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_shutdown_pargs& obj);
};

typedef struct _Aim_shutdown_result__isset {
  _Aim_shutdown_result__isset() : libvirtException(false) {}
  bool libvirtException :1;
} _Aim_shutdown_result__isset;

class Aim_shutdown_result {
 public:

  static const char* ascii_fingerprint; // = "EAF4C873F89672ABB97ED74219F64E64";
  static const uint8_t binary_fingerprint[16]; // = {0xEA,0xF4,0xC8,0x73,0xF8,0x96,0x72,0xAB,0xB9,0x7E,0xD7,0x42,0x19,0xF6,0x4E,0x64};

  Aim_shutdown_result(const Aim_shutdown_result&);
  Aim_shutdown_result& operator=(const Aim_shutdown_result&);
  Aim_shutdown_result() {
  }

  virtual ~Aim_shutdown_result() throw();
  LibvirtException libvirtException;

  _Aim_shutdown_result__isset __isset;

  void __set_libvirtException(const LibvirtException& val);

  bool operator == (const Aim_shutdown_result & rhs) const
  {
    if (!(libvirtException == rhs.libvirtException))
      return false;
    return true;
  }
  bool operator != (const Aim_shutdown_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_shutdown_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_shutdown_result& obj);
};

typedef struct _Aim_shutdown_presult__isset {
  _Aim_shutdown_presult__isset() : libvirtException(false) {}
  bool libvirtException :1;
} _Aim_shutdown_presult__isset;

class Aim_shutdown_presult {
 public:

  static const char* ascii_fingerprint; // = "EAF4C873F89672ABB97ED74219F64E64";
  static const uint8_t binary_fingerprint[16]; // = {0xEA,0xF4,0xC8,0x73,0xF8,0x96,0x72,0xAB,0xB9,0x7E,0xD7,0x42,0x19,0xF6,0x4E,0x64};


  virtual ~Aim_shutdown_presult() throw();
  LibvirtException libvirtException;

  _Aim_shutdown_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Aim_shutdown_presult& obj);
};

typedef struct _Aim_reset_args__isset {
  _Aim_reset_args__isset() : domainName(false) {}
  bool domainName :1;
} _Aim_reset_args__isset;

class Aim_reset_args {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  Aim_reset_args(const Aim_reset_args&);
  Aim_reset_args& operator=(const Aim_reset_args&);
  Aim_reset_args() : domainName() {
  }

  virtual ~Aim_reset_args() throw();
  std::string domainName;

  _Aim_reset_args__isset __isset;

  void __set_domainName(const std::string& val);

  bool operator == (const Aim_reset_args & rhs) const
  {
    if (!(domainName == rhs.domainName))
      return false;
    return true;
  }
  bool operator != (const Aim_reset_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_reset_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_reset_args& obj);
};


class Aim_reset_pargs {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};


  virtual ~Aim_reset_pargs() throw();
  const std::string* domainName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_reset_pargs& obj);
};

typedef struct _Aim_reset_result__isset {
  _Aim_reset_result__isset() : libvirtException(false) {}
  bool libvirtException :1;
} _Aim_reset_result__isset;

class Aim_reset_result {
 public:

  static const char* ascii_fingerprint; // = "EAF4C873F89672ABB97ED74219F64E64";
  static const uint8_t binary_fingerprint[16]; // = {0xEA,0xF4,0xC8,0x73,0xF8,0x96,0x72,0xAB,0xB9,0x7E,0xD7,0x42,0x19,0xF6,0x4E,0x64};

  Aim_reset_result(const Aim_reset_result&);
  Aim_reset_result& operator=(const Aim_reset_result&);
  Aim_reset_result() {
  }

  virtual ~Aim_reset_result() throw();
  LibvirtException libvirtException;

  _Aim_reset_result__isset __isset;

  void __set_libvirtException(const LibvirtException& val);

  bool operator == (const Aim_reset_result & rhs) const
  {
    if (!(libvirtException == rhs.libvirtException))
      return false;
    return true;
  }
  bool operator != (const Aim_reset_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_reset_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_reset_result& obj);
};

typedef struct _Aim_reset_presult__isset {
  _Aim_reset_presult__isset() : libvirtException(false) {}
  bool libvirtException :1;
} _Aim_reset_presult__isset;

class Aim_reset_presult {
 public:

  static const char* ascii_fingerprint; // = "EAF4C873F89672ABB97ED74219F64E64";
  static const uint8_t binary_fingerprint[16]; // = {0xEA,0xF4,0xC8,0x73,0xF8,0x96,0x72,0xAB,0xB9,0x7E,0xD7,0x42,0x19,0xF6,0x4E,0x64};


  virtual ~Aim_reset_presult() throw();
  LibvirtException libvirtException;

  _Aim_reset_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Aim_reset_presult& obj);
};

typedef struct _Aim_pause_args__isset {
  _Aim_pause_args__isset() : domainName(false) {}
  bool domainName :1;
} _Aim_pause_args__isset;

class Aim_pause_args {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  Aim_pause_args(const Aim_pause_args&);
  Aim_pause_args& operator=(const Aim_pause_args&);
  Aim_pause_args() : domainName() {
  }

  virtual ~Aim_pause_args() throw();
  std::string domainName;

  _Aim_pause_args__isset __isset;

  void __set_domainName(const std::string& val);

  bool operator == (const Aim_pause_args & rhs) const
  {
    if (!(domainName == rhs.domainName))
      return false;
    return true;
  }
  bool operator != (const Aim_pause_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_pause_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_pause_args& obj);
};


class Aim_pause_pargs {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};


  virtual ~Aim_pause_pargs() throw();
  const std::string* domainName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_pause_pargs& obj);
};

typedef struct _Aim_pause_result__isset {
  _Aim_pause_result__isset() : libvirtException(false) {}
  bool libvirtException :1;
} _Aim_pause_result__isset;

class Aim_pause_result {
 public:

  static const char* ascii_fingerprint; // = "EAF4C873F89672ABB97ED74219F64E64";
  static const uint8_t binary_fingerprint[16]; // = {0xEA,0xF4,0xC8,0x73,0xF8,0x96,0x72,0xAB,0xB9,0x7E,0xD7,0x42,0x19,0xF6,0x4E,0x64};

  Aim_pause_result(const Aim_pause_result&);
  Aim_pause_result& operator=(const Aim_pause_result&);
  Aim_pause_result() {
  }

  virtual ~Aim_pause_result() throw();
  LibvirtException libvirtException;

  _Aim_pause_result__isset __isset;

  void __set_libvirtException(const LibvirtException& val);

  bool operator == (const Aim_pause_result & rhs) const
  {
    if (!(libvirtException == rhs.libvirtException))
      return false;
    return true;
  }
  bool operator != (const Aim_pause_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_pause_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_pause_result& obj);
};

typedef struct _Aim_pause_presult__isset {
  _Aim_pause_presult__isset() : libvirtException(false) {}
  bool libvirtException :1;
} _Aim_pause_presult__isset;

class Aim_pause_presult {
 public:

  static const char* ascii_fingerprint; // = "EAF4C873F89672ABB97ED74219F64E64";
  static const uint8_t binary_fingerprint[16]; // = {0xEA,0xF4,0xC8,0x73,0xF8,0x96,0x72,0xAB,0xB9,0x7E,0xD7,0x42,0x19,0xF6,0x4E,0x64};


  virtual ~Aim_pause_presult() throw();
  LibvirtException libvirtException;

  _Aim_pause_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Aim_pause_presult& obj);
};

typedef struct _Aim_resume_args__isset {
  _Aim_resume_args__isset() : domainName(false) {}
  bool domainName :1;
} _Aim_resume_args__isset;

class Aim_resume_args {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  Aim_resume_args(const Aim_resume_args&);
  Aim_resume_args& operator=(const Aim_resume_args&);
  Aim_resume_args() : domainName() {
  }

  virtual ~Aim_resume_args() throw();
  std::string domainName;

  _Aim_resume_args__isset __isset;

  void __set_domainName(const std::string& val);

  bool operator == (const Aim_resume_args & rhs) const
  {
    if (!(domainName == rhs.domainName))
      return false;
    return true;
  }
  bool operator != (const Aim_resume_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_resume_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_resume_args& obj);
};


class Aim_resume_pargs {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};


  virtual ~Aim_resume_pargs() throw();
  const std::string* domainName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_resume_pargs& obj);
};

typedef struct _Aim_resume_result__isset {
  _Aim_resume_result__isset() : libvirtException(false) {}
  bool libvirtException :1;
} _Aim_resume_result__isset;

class Aim_resume_result {
 public:

  static const char* ascii_fingerprint; // = "EAF4C873F89672ABB97ED74219F64E64";
  static const uint8_t binary_fingerprint[16]; // = {0xEA,0xF4,0xC8,0x73,0xF8,0x96,0x72,0xAB,0xB9,0x7E,0xD7,0x42,0x19,0xF6,0x4E,0x64};

  Aim_resume_result(const Aim_resume_result&);
  Aim_resume_result& operator=(const Aim_resume_result&);
  Aim_resume_result() {
  }

  virtual ~Aim_resume_result() throw();
  LibvirtException libvirtException;

  _Aim_resume_result__isset __isset;

  void __set_libvirtException(const LibvirtException& val);

  bool operator == (const Aim_resume_result & rhs) const
  {
    if (!(libvirtException == rhs.libvirtException))
      return false;
    return true;
  }
  bool operator != (const Aim_resume_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_resume_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_resume_result& obj);
};

typedef struct _Aim_resume_presult__isset {
  _Aim_resume_presult__isset() : libvirtException(false) {}
  bool libvirtException :1;
} _Aim_resume_presult__isset;

class Aim_resume_presult {
 public:

  static const char* ascii_fingerprint; // = "EAF4C873F89672ABB97ED74219F64E64";
  static const uint8_t binary_fingerprint[16]; // = {0xEA,0xF4,0xC8,0x73,0xF8,0x96,0x72,0xAB,0xB9,0x7E,0xD7,0x42,0x19,0xF6,0x4E,0x64};


  virtual ~Aim_resume_presult() throw();
  LibvirtException libvirtException;

  _Aim_resume_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Aim_resume_presult& obj);
};

typedef struct _Aim_createISCSIStoragePool_args__isset {
  _Aim_createISCSIStoragePool_args__isset() : name(false), host(false), iqn(false), targetPath(false) {}
  bool name :1;
  bool host :1;
  bool iqn :1;
  bool targetPath :1;
} _Aim_createISCSIStoragePool_args__isset;

class Aim_createISCSIStoragePool_args {
 public:

  static const char* ascii_fingerprint; // = "C93D890311F28844166CF6E571EB3AC2";
  static const uint8_t binary_fingerprint[16]; // = {0xC9,0x3D,0x89,0x03,0x11,0xF2,0x88,0x44,0x16,0x6C,0xF6,0xE5,0x71,0xEB,0x3A,0xC2};

  Aim_createISCSIStoragePool_args(const Aim_createISCSIStoragePool_args&);
  Aim_createISCSIStoragePool_args& operator=(const Aim_createISCSIStoragePool_args&);
  Aim_createISCSIStoragePool_args() : name(), host(), iqn(), targetPath() {
  }

  virtual ~Aim_createISCSIStoragePool_args() throw();
  std::string name;
  std::string host;
  std::string iqn;
  std::string targetPath;

  _Aim_createISCSIStoragePool_args__isset __isset;

  void __set_name(const std::string& val);

  void __set_host(const std::string& val);

  void __set_iqn(const std::string& val);

  void __set_targetPath(const std::string& val);

  bool operator == (const Aim_createISCSIStoragePool_args & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(host == rhs.host))
      return false;
    if (!(iqn == rhs.iqn))
      return false;
    if (!(targetPath == rhs.targetPath))
      return false;
    return true;
  }
  bool operator != (const Aim_createISCSIStoragePool_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_createISCSIStoragePool_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_createISCSIStoragePool_args& obj);
};


class Aim_createISCSIStoragePool_pargs {
 public:

  static const char* ascii_fingerprint; // = "C93D890311F28844166CF6E571EB3AC2";
  static const uint8_t binary_fingerprint[16]; // = {0xC9,0x3D,0x89,0x03,0x11,0xF2,0x88,0x44,0x16,0x6C,0xF6,0xE5,0x71,0xEB,0x3A,0xC2};


  virtual ~Aim_createISCSIStoragePool_pargs() throw();
  const std::string* name;
  const std::string* host;
  const std::string* iqn;
  const std::string* targetPath;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_createISCSIStoragePool_pargs& obj);
};

typedef struct _Aim_createISCSIStoragePool_result__isset {
  _Aim_createISCSIStoragePool_result__isset() : libvirtException(false) {}
  bool libvirtException :1;
} _Aim_createISCSIStoragePool_result__isset;

class Aim_createISCSIStoragePool_result {
 public:

  static const char* ascii_fingerprint; // = "EAF4C873F89672ABB97ED74219F64E64";
  static const uint8_t binary_fingerprint[16]; // = {0xEA,0xF4,0xC8,0x73,0xF8,0x96,0x72,0xAB,0xB9,0x7E,0xD7,0x42,0x19,0xF6,0x4E,0x64};

  Aim_createISCSIStoragePool_result(const Aim_createISCSIStoragePool_result&);
  Aim_createISCSIStoragePool_result& operator=(const Aim_createISCSIStoragePool_result&);
  Aim_createISCSIStoragePool_result() {
  }

  virtual ~Aim_createISCSIStoragePool_result() throw();
  LibvirtException libvirtException;

  _Aim_createISCSIStoragePool_result__isset __isset;

  void __set_libvirtException(const LibvirtException& val);

  bool operator == (const Aim_createISCSIStoragePool_result & rhs) const
  {
    if (!(libvirtException == rhs.libvirtException))
      return false;
    return true;
  }
  bool operator != (const Aim_createISCSIStoragePool_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_createISCSIStoragePool_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_createISCSIStoragePool_result& obj);
};

typedef struct _Aim_createISCSIStoragePool_presult__isset {
  _Aim_createISCSIStoragePool_presult__isset() : libvirtException(false) {}
  bool libvirtException :1;
} _Aim_createISCSIStoragePool_presult__isset;

class Aim_createISCSIStoragePool_presult {
 public:

  static const char* ascii_fingerprint; // = "EAF4C873F89672ABB97ED74219F64E64";
  static const uint8_t binary_fingerprint[16]; // = {0xEA,0xF4,0xC8,0x73,0xF8,0x96,0x72,0xAB,0xB9,0x7E,0xD7,0x42,0x19,0xF6,0x4E,0x64};


  virtual ~Aim_createISCSIStoragePool_presult() throw();
  LibvirtException libvirtException;

  _Aim_createISCSIStoragePool_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Aim_createISCSIStoragePool_presult& obj);
};

typedef struct _Aim_createNFSStoragePool_args__isset {
  _Aim_createNFSStoragePool_args__isset() : name(false), host(false), dir(false), targetPath(false) {}
  bool name :1;
  bool host :1;
  bool dir :1;
  bool targetPath :1;
} _Aim_createNFSStoragePool_args__isset;

class Aim_createNFSStoragePool_args {
 public:

  static const char* ascii_fingerprint; // = "C93D890311F28844166CF6E571EB3AC2";
  static const uint8_t binary_fingerprint[16]; // = {0xC9,0x3D,0x89,0x03,0x11,0xF2,0x88,0x44,0x16,0x6C,0xF6,0xE5,0x71,0xEB,0x3A,0xC2};

  Aim_createNFSStoragePool_args(const Aim_createNFSStoragePool_args&);
  Aim_createNFSStoragePool_args& operator=(const Aim_createNFSStoragePool_args&);
  Aim_createNFSStoragePool_args() : name(), host(), dir(), targetPath() {
  }

  virtual ~Aim_createNFSStoragePool_args() throw();
  std::string name;
  std::string host;
  std::string dir;
  std::string targetPath;

  _Aim_createNFSStoragePool_args__isset __isset;

  void __set_name(const std::string& val);

  void __set_host(const std::string& val);

  void __set_dir(const std::string& val);

  void __set_targetPath(const std::string& val);

  bool operator == (const Aim_createNFSStoragePool_args & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(host == rhs.host))
      return false;
    if (!(dir == rhs.dir))
      return false;
    if (!(targetPath == rhs.targetPath))
      return false;
    return true;
  }
  bool operator != (const Aim_createNFSStoragePool_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_createNFSStoragePool_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_createNFSStoragePool_args& obj);
};


class Aim_createNFSStoragePool_pargs {
 public:

  static const char* ascii_fingerprint; // = "C93D890311F28844166CF6E571EB3AC2";
  static const uint8_t binary_fingerprint[16]; // = {0xC9,0x3D,0x89,0x03,0x11,0xF2,0x88,0x44,0x16,0x6C,0xF6,0xE5,0x71,0xEB,0x3A,0xC2};


  virtual ~Aim_createNFSStoragePool_pargs() throw();
  const std::string* name;
  const std::string* host;
  const std::string* dir;
  const std::string* targetPath;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_createNFSStoragePool_pargs& obj);
};

typedef struct _Aim_createNFSStoragePool_result__isset {
  _Aim_createNFSStoragePool_result__isset() : libvirtException(false) {}
  bool libvirtException :1;
} _Aim_createNFSStoragePool_result__isset;

class Aim_createNFSStoragePool_result {
 public:

  static const char* ascii_fingerprint; // = "EAF4C873F89672ABB97ED74219F64E64";
  static const uint8_t binary_fingerprint[16]; // = {0xEA,0xF4,0xC8,0x73,0xF8,0x96,0x72,0xAB,0xB9,0x7E,0xD7,0x42,0x19,0xF6,0x4E,0x64};

  Aim_createNFSStoragePool_result(const Aim_createNFSStoragePool_result&);
  Aim_createNFSStoragePool_result& operator=(const Aim_createNFSStoragePool_result&);
  Aim_createNFSStoragePool_result() {
  }

  virtual ~Aim_createNFSStoragePool_result() throw();
  LibvirtException libvirtException;

  _Aim_createNFSStoragePool_result__isset __isset;

  void __set_libvirtException(const LibvirtException& val);

  bool operator == (const Aim_createNFSStoragePool_result & rhs) const
  {
    if (!(libvirtException == rhs.libvirtException))
      return false;
    return true;
  }
  bool operator != (const Aim_createNFSStoragePool_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_createNFSStoragePool_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_createNFSStoragePool_result& obj);
};

typedef struct _Aim_createNFSStoragePool_presult__isset {
  _Aim_createNFSStoragePool_presult__isset() : libvirtException(false) {}
  bool libvirtException :1;
} _Aim_createNFSStoragePool_presult__isset;

class Aim_createNFSStoragePool_presult {
 public:

  static const char* ascii_fingerprint; // = "EAF4C873F89672ABB97ED74219F64E64";
  static const uint8_t binary_fingerprint[16]; // = {0xEA,0xF4,0xC8,0x73,0xF8,0x96,0x72,0xAB,0xB9,0x7E,0xD7,0x42,0x19,0xF6,0x4E,0x64};


  virtual ~Aim_createNFSStoragePool_presult() throw();
  LibvirtException libvirtException;

  _Aim_createNFSStoragePool_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Aim_createNFSStoragePool_presult& obj);
};

typedef struct _Aim_createDirStoragePool_args__isset {
  _Aim_createDirStoragePool_args__isset() : name(false), targetPath(false) {}
  bool name :1;
  bool targetPath :1;
} _Aim_createDirStoragePool_args__isset;

class Aim_createDirStoragePool_args {
 public:

  static const char* ascii_fingerprint; // = "07A9615F837F7D0A952B595DD3020972";
  static const uint8_t binary_fingerprint[16]; // = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};

  Aim_createDirStoragePool_args(const Aim_createDirStoragePool_args&);
  Aim_createDirStoragePool_args& operator=(const Aim_createDirStoragePool_args&);
  Aim_createDirStoragePool_args() : name(), targetPath() {
  }

  virtual ~Aim_createDirStoragePool_args() throw();
  std::string name;
  std::string targetPath;

  _Aim_createDirStoragePool_args__isset __isset;

  void __set_name(const std::string& val);

  void __set_targetPath(const std::string& val);

  bool operator == (const Aim_createDirStoragePool_args & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(targetPath == rhs.targetPath))
      return false;
    return true;
  }
  bool operator != (const Aim_createDirStoragePool_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_createDirStoragePool_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_createDirStoragePool_args& obj);
};


class Aim_createDirStoragePool_pargs {
 public:

  static const char* ascii_fingerprint; // = "07A9615F837F7D0A952B595DD3020972";
  static const uint8_t binary_fingerprint[16]; // = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};


  virtual ~Aim_createDirStoragePool_pargs() throw();
  const std::string* name;
  const std::string* targetPath;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_createDirStoragePool_pargs& obj);
};

typedef struct _Aim_createDirStoragePool_result__isset {
  _Aim_createDirStoragePool_result__isset() : libvirtException(false) {}
  bool libvirtException :1;
} _Aim_createDirStoragePool_result__isset;

class Aim_createDirStoragePool_result {
 public:

  static const char* ascii_fingerprint; // = "EAF4C873F89672ABB97ED74219F64E64";
  static const uint8_t binary_fingerprint[16]; // = {0xEA,0xF4,0xC8,0x73,0xF8,0x96,0x72,0xAB,0xB9,0x7E,0xD7,0x42,0x19,0xF6,0x4E,0x64};

  Aim_createDirStoragePool_result(const Aim_createDirStoragePool_result&);
  Aim_createDirStoragePool_result& operator=(const Aim_createDirStoragePool_result&);
  Aim_createDirStoragePool_result() {
  }

  virtual ~Aim_createDirStoragePool_result() throw();
  LibvirtException libvirtException;

  _Aim_createDirStoragePool_result__isset __isset;

  void __set_libvirtException(const LibvirtException& val);

  bool operator == (const Aim_createDirStoragePool_result & rhs) const
  {
    if (!(libvirtException == rhs.libvirtException))
      return false;
    return true;
  }
  bool operator != (const Aim_createDirStoragePool_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_createDirStoragePool_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_createDirStoragePool_result& obj);
};

typedef struct _Aim_createDirStoragePool_presult__isset {
  _Aim_createDirStoragePool_presult__isset() : libvirtException(false) {}
  bool libvirtException :1;
} _Aim_createDirStoragePool_presult__isset;

class Aim_createDirStoragePool_presult {
 public:

  static const char* ascii_fingerprint; // = "EAF4C873F89672ABB97ED74219F64E64";
  static const uint8_t binary_fingerprint[16]; // = {0xEA,0xF4,0xC8,0x73,0xF8,0x96,0x72,0xAB,0xB9,0x7E,0xD7,0x42,0x19,0xF6,0x4E,0x64};


  virtual ~Aim_createDirStoragePool_presult() throw();
  LibvirtException libvirtException;

  _Aim_createDirStoragePool_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Aim_createDirStoragePool_presult& obj);
};

typedef struct _Aim_createDisk_args__isset {
  _Aim_createDisk_args__isset() : poolName(false), name(false), capacityInKb(false), allocationInKb(false), format(false) {}
  bool poolName :1;
  bool name :1;
  bool capacityInKb :1;
  bool allocationInKb :1;
  bool format :1;
} _Aim_createDisk_args__isset;

class Aim_createDisk_args {
 public:

  static const char* ascii_fingerprint; // = "9A5C60D485B88A0E01B8594C5CDA5299";
  static const uint8_t binary_fingerprint[16]; // = {0x9A,0x5C,0x60,0xD4,0x85,0xB8,0x8A,0x0E,0x01,0xB8,0x59,0x4C,0x5C,0xDA,0x52,0x99};

  Aim_createDisk_args(const Aim_createDisk_args&);
  Aim_createDisk_args& operator=(const Aim_createDisk_args&);
  Aim_createDisk_args() : poolName(), name(), capacityInKb(0), allocationInKb(0), format() {
  }

  virtual ~Aim_createDisk_args() throw();
  std::string poolName;
  std::string name;
  double capacityInKb;
  double allocationInKb;
  std::string format;

  _Aim_createDisk_args__isset __isset;

  void __set_poolName(const std::string& val);

  void __set_name(const std::string& val);

  void __set_capacityInKb(const double val);

  void __set_allocationInKb(const double val);

  void __set_format(const std::string& val);

  bool operator == (const Aim_createDisk_args & rhs) const
  {
    if (!(poolName == rhs.poolName))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(capacityInKb == rhs.capacityInKb))
      return false;
    if (!(allocationInKb == rhs.allocationInKb))
      return false;
    if (!(format == rhs.format))
      return false;
    return true;
  }
  bool operator != (const Aim_createDisk_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_createDisk_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_createDisk_args& obj);
};


class Aim_createDisk_pargs {
 public:

  static const char* ascii_fingerprint; // = "9A5C60D485B88A0E01B8594C5CDA5299";
  static const uint8_t binary_fingerprint[16]; // = {0x9A,0x5C,0x60,0xD4,0x85,0xB8,0x8A,0x0E,0x01,0xB8,0x59,0x4C,0x5C,0xDA,0x52,0x99};


  virtual ~Aim_createDisk_pargs() throw();
  const std::string* poolName;
  const std::string* name;
  const double* capacityInKb;
  const double* allocationInKb;
  const std::string* format;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_createDisk_pargs& obj);
};

typedef struct _Aim_createDisk_result__isset {
  _Aim_createDisk_result__isset() : libvirtException(false) {}
  bool libvirtException :1;
} _Aim_createDisk_result__isset;

class Aim_createDisk_result {
 public:

  static const char* ascii_fingerprint; // = "EAF4C873F89672ABB97ED74219F64E64";
  static const uint8_t binary_fingerprint[16]; // = {0xEA,0xF4,0xC8,0x73,0xF8,0x96,0x72,0xAB,0xB9,0x7E,0xD7,0x42,0x19,0xF6,0x4E,0x64};

  Aim_createDisk_result(const Aim_createDisk_result&);
  Aim_createDisk_result& operator=(const Aim_createDisk_result&);
  Aim_createDisk_result() {
  }

  virtual ~Aim_createDisk_result() throw();
  LibvirtException libvirtException;

  _Aim_createDisk_result__isset __isset;

  void __set_libvirtException(const LibvirtException& val);

  bool operator == (const Aim_createDisk_result & rhs) const
  {
    if (!(libvirtException == rhs.libvirtException))
      return false;
    return true;
  }
  bool operator != (const Aim_createDisk_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_createDisk_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_createDisk_result& obj);
};

typedef struct _Aim_createDisk_presult__isset {
  _Aim_createDisk_presult__isset() : libvirtException(false) {}
  bool libvirtException :1;
} _Aim_createDisk_presult__isset;

class Aim_createDisk_presult {
 public:

  static const char* ascii_fingerprint; // = "EAF4C873F89672ABB97ED74219F64E64";
  static const uint8_t binary_fingerprint[16]; // = {0xEA,0xF4,0xC8,0x73,0xF8,0x96,0x72,0xAB,0xB9,0x7E,0xD7,0x42,0x19,0xF6,0x4E,0x64};


  virtual ~Aim_createDisk_presult() throw();
  LibvirtException libvirtException;

  _Aim_createDisk_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Aim_createDisk_presult& obj);
};

typedef struct _Aim_deleteDisk_args__isset {
  _Aim_deleteDisk_args__isset() : poolName(false), name(false) {}
  bool poolName :1;
  bool name :1;
} _Aim_deleteDisk_args__isset;

class Aim_deleteDisk_args {
 public:

  static const char* ascii_fingerprint; // = "07A9615F837F7D0A952B595DD3020972";
  static const uint8_t binary_fingerprint[16]; // = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};

  Aim_deleteDisk_args(const Aim_deleteDisk_args&);
  Aim_deleteDisk_args& operator=(const Aim_deleteDisk_args&);
  Aim_deleteDisk_args() : poolName(), name() {
  }

  virtual ~Aim_deleteDisk_args() throw();
  std::string poolName;
  std::string name;

  _Aim_deleteDisk_args__isset __isset;

  void __set_poolName(const std::string& val);

  void __set_name(const std::string& val);

  bool operator == (const Aim_deleteDisk_args & rhs) const
  {
    if (!(poolName == rhs.poolName))
      return false;
    if (!(name == rhs.name))
      return false;
    return true;
  }
  bool operator != (const Aim_deleteDisk_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_deleteDisk_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_deleteDisk_args& obj);
};


class Aim_deleteDisk_pargs {
 public:

  static const char* ascii_fingerprint; // = "07A9615F837F7D0A952B595DD3020972";
  static const uint8_t binary_fingerprint[16]; // = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};


  virtual ~Aim_deleteDisk_pargs() throw();
  const std::string* poolName;
  const std::string* name;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_deleteDisk_pargs& obj);
};

typedef struct _Aim_deleteDisk_result__isset {
  _Aim_deleteDisk_result__isset() : libvirtException(false) {}
  bool libvirtException :1;
} _Aim_deleteDisk_result__isset;

class Aim_deleteDisk_result {
 public:

  static const char* ascii_fingerprint; // = "EAF4C873F89672ABB97ED74219F64E64";
  static const uint8_t binary_fingerprint[16]; // = {0xEA,0xF4,0xC8,0x73,0xF8,0x96,0x72,0xAB,0xB9,0x7E,0xD7,0x42,0x19,0xF6,0x4E,0x64};

  Aim_deleteDisk_result(const Aim_deleteDisk_result&);
  Aim_deleteDisk_result& operator=(const Aim_deleteDisk_result&);
  Aim_deleteDisk_result() {
  }

  virtual ~Aim_deleteDisk_result() throw();
  LibvirtException libvirtException;

  _Aim_deleteDisk_result__isset __isset;

  void __set_libvirtException(const LibvirtException& val);

  bool operator == (const Aim_deleteDisk_result & rhs) const
  {
    if (!(libvirtException == rhs.libvirtException))
      return false;
    return true;
  }
  bool operator != (const Aim_deleteDisk_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_deleteDisk_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_deleteDisk_result& obj);
};

typedef struct _Aim_deleteDisk_presult__isset {
  _Aim_deleteDisk_presult__isset() : libvirtException(false) {}
  bool libvirtException :1;
} _Aim_deleteDisk_presult__isset;

class Aim_deleteDisk_presult {
 public:

  static const char* ascii_fingerprint; // = "EAF4C873F89672ABB97ED74219F64E64";
  static const uint8_t binary_fingerprint[16]; // = {0xEA,0xF4,0xC8,0x73,0xF8,0x96,0x72,0xAB,0xB9,0x7E,0xD7,0x42,0x19,0xF6,0x4E,0x64};


  virtual ~Aim_deleteDisk_presult() throw();
  LibvirtException libvirtException;

  _Aim_deleteDisk_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Aim_deleteDisk_presult& obj);
};

typedef struct _Aim_resizeVol_args__isset {
  _Aim_resizeVol_args__isset() : poolName(false), name(false), capacityInKb(false) {}
  bool poolName :1;
  bool name :1;
  bool capacityInKb :1;
} _Aim_resizeVol_args__isset;

class Aim_resizeVol_args {
 public:

  static const char* ascii_fingerprint; // = "AD85F51ADB3273FFDB452ABB0A91574B";
  static const uint8_t binary_fingerprint[16]; // = {0xAD,0x85,0xF5,0x1A,0xDB,0x32,0x73,0xFF,0xDB,0x45,0x2A,0xBB,0x0A,0x91,0x57,0x4B};

  Aim_resizeVol_args(const Aim_resizeVol_args&);
  Aim_resizeVol_args& operator=(const Aim_resizeVol_args&);
  Aim_resizeVol_args() : poolName(), name(), capacityInKb(0) {
  }

  virtual ~Aim_resizeVol_args() throw();
  std::string poolName;
  std::string name;
  double capacityInKb;

  _Aim_resizeVol_args__isset __isset;

  void __set_poolName(const std::string& val);

  void __set_name(const std::string& val);

  void __set_capacityInKb(const double val);

  bool operator == (const Aim_resizeVol_args & rhs) const
  {
    if (!(poolName == rhs.poolName))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(capacityInKb == rhs.capacityInKb))
      return false;
    return true;
  }
  bool operator != (const Aim_resizeVol_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_resizeVol_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_resizeVol_args& obj);
};


class Aim_resizeVol_pargs {
 public:

  static const char* ascii_fingerprint; // = "AD85F51ADB3273FFDB452ABB0A91574B";
  static const uint8_t binary_fingerprint[16]; // = {0xAD,0x85,0xF5,0x1A,0xDB,0x32,0x73,0xFF,0xDB,0x45,0x2A,0xBB,0x0A,0x91,0x57,0x4B};


  virtual ~Aim_resizeVol_pargs() throw();
  const std::string* poolName;
  const std::string* name;
  const double* capacityInKb;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_resizeVol_pargs& obj);
};

typedef struct _Aim_resizeVol_result__isset {
  _Aim_resizeVol_result__isset() : libvirtException(false) {}
  bool libvirtException :1;
} _Aim_resizeVol_result__isset;

class Aim_resizeVol_result {
 public:

  static const char* ascii_fingerprint; // = "EAF4C873F89672ABB97ED74219F64E64";
  static const uint8_t binary_fingerprint[16]; // = {0xEA,0xF4,0xC8,0x73,0xF8,0x96,0x72,0xAB,0xB9,0x7E,0xD7,0x42,0x19,0xF6,0x4E,0x64};

  Aim_resizeVol_result(const Aim_resizeVol_result&);
  Aim_resizeVol_result& operator=(const Aim_resizeVol_result&);
  Aim_resizeVol_result() {
  }

  virtual ~Aim_resizeVol_result() throw();
  LibvirtException libvirtException;

  _Aim_resizeVol_result__isset __isset;

  void __set_libvirtException(const LibvirtException& val);

  bool operator == (const Aim_resizeVol_result & rhs) const
  {
    if (!(libvirtException == rhs.libvirtException))
      return false;
    return true;
  }
  bool operator != (const Aim_resizeVol_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_resizeVol_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_resizeVol_result& obj);
};

typedef struct _Aim_resizeVol_presult__isset {
  _Aim_resizeVol_presult__isset() : libvirtException(false) {}
  bool libvirtException :1;
} _Aim_resizeVol_presult__isset;

class Aim_resizeVol_presult {
 public:

  static const char* ascii_fingerprint; // = "EAF4C873F89672ABB97ED74219F64E64";
  static const uint8_t binary_fingerprint[16]; // = {0xEA,0xF4,0xC8,0x73,0xF8,0x96,0x72,0xAB,0xB9,0x7E,0xD7,0x42,0x19,0xF6,0x4E,0x64};


  virtual ~Aim_resizeVol_presult() throw();
  LibvirtException libvirtException;

  _Aim_resizeVol_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Aim_resizeVol_presult& obj);
};

typedef struct _Aim_resizeDisk_args__isset {
  _Aim_resizeDisk_args__isset() : domainName(false), diskPath(false), diskSizeInKb(false) {}
  bool domainName :1;
  bool diskPath :1;
  bool diskSizeInKb :1;
} _Aim_resizeDisk_args__isset;

class Aim_resizeDisk_args {
 public:

  static const char* ascii_fingerprint; // = "AD85F51ADB3273FFDB452ABB0A91574B";
  static const uint8_t binary_fingerprint[16]; // = {0xAD,0x85,0xF5,0x1A,0xDB,0x32,0x73,0xFF,0xDB,0x45,0x2A,0xBB,0x0A,0x91,0x57,0x4B};

  Aim_resizeDisk_args(const Aim_resizeDisk_args&);
  Aim_resizeDisk_args& operator=(const Aim_resizeDisk_args&);
  Aim_resizeDisk_args() : domainName(), diskPath(), diskSizeInKb(0) {
  }

  virtual ~Aim_resizeDisk_args() throw();
  std::string domainName;
  std::string diskPath;
  double diskSizeInKb;

  _Aim_resizeDisk_args__isset __isset;

  void __set_domainName(const std::string& val);

  void __set_diskPath(const std::string& val);

  void __set_diskSizeInKb(const double val);

  bool operator == (const Aim_resizeDisk_args & rhs) const
  {
    if (!(domainName == rhs.domainName))
      return false;
    if (!(diskPath == rhs.diskPath))
      return false;
    if (!(diskSizeInKb == rhs.diskSizeInKb))
      return false;
    return true;
  }
  bool operator != (const Aim_resizeDisk_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_resizeDisk_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_resizeDisk_args& obj);
};


class Aim_resizeDisk_pargs {
 public:

  static const char* ascii_fingerprint; // = "AD85F51ADB3273FFDB452ABB0A91574B";
  static const uint8_t binary_fingerprint[16]; // = {0xAD,0x85,0xF5,0x1A,0xDB,0x32,0x73,0xFF,0xDB,0x45,0x2A,0xBB,0x0A,0x91,0x57,0x4B};


  virtual ~Aim_resizeDisk_pargs() throw();
  const std::string* domainName;
  const std::string* diskPath;
  const double* diskSizeInKb;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_resizeDisk_pargs& obj);
};

typedef struct _Aim_resizeDisk_result__isset {
  _Aim_resizeDisk_result__isset() : libvirtException(false) {}
  bool libvirtException :1;
} _Aim_resizeDisk_result__isset;

class Aim_resizeDisk_result {
 public:

  static const char* ascii_fingerprint; // = "EAF4C873F89672ABB97ED74219F64E64";
  static const uint8_t binary_fingerprint[16]; // = {0xEA,0xF4,0xC8,0x73,0xF8,0x96,0x72,0xAB,0xB9,0x7E,0xD7,0x42,0x19,0xF6,0x4E,0x64};

  Aim_resizeDisk_result(const Aim_resizeDisk_result&);
  Aim_resizeDisk_result& operator=(const Aim_resizeDisk_result&);
  Aim_resizeDisk_result() {
  }

  virtual ~Aim_resizeDisk_result() throw();
  LibvirtException libvirtException;

  _Aim_resizeDisk_result__isset __isset;

  void __set_libvirtException(const LibvirtException& val);

  bool operator == (const Aim_resizeDisk_result & rhs) const
  {
    if (!(libvirtException == rhs.libvirtException))
      return false;
    return true;
  }
  bool operator != (const Aim_resizeDisk_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_resizeDisk_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_resizeDisk_result& obj);
};

typedef struct _Aim_resizeDisk_presult__isset {
  _Aim_resizeDisk_presult__isset() : libvirtException(false) {}
  bool libvirtException :1;
} _Aim_resizeDisk_presult__isset;

class Aim_resizeDisk_presult {
 public:

  static const char* ascii_fingerprint; // = "EAF4C873F89672ABB97ED74219F64E64";
  static const uint8_t binary_fingerprint[16]; // = {0xEA,0xF4,0xC8,0x73,0xF8,0x96,0x72,0xAB,0xB9,0x7E,0xD7,0x42,0x19,0xF6,0x4E,0x64};


  virtual ~Aim_resizeDisk_presult() throw();
  LibvirtException libvirtException;

  _Aim_resizeDisk_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Aim_resizeDisk_presult& obj);
};

typedef struct _Aim_getDomainBlockInfo_args__isset {
  _Aim_getDomainBlockInfo_args__isset() : domainName(false), diskPath(false) {}
  bool domainName :1;
  bool diskPath :1;
} _Aim_getDomainBlockInfo_args__isset;

class Aim_getDomainBlockInfo_args {
 public:

  static const char* ascii_fingerprint; // = "07A9615F837F7D0A952B595DD3020972";
  static const uint8_t binary_fingerprint[16]; // = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};

  Aim_getDomainBlockInfo_args(const Aim_getDomainBlockInfo_args&);
  Aim_getDomainBlockInfo_args& operator=(const Aim_getDomainBlockInfo_args&);
  Aim_getDomainBlockInfo_args() : domainName(), diskPath() {
  }

  virtual ~Aim_getDomainBlockInfo_args() throw();
  std::string domainName;
  std::string diskPath;

  _Aim_getDomainBlockInfo_args__isset __isset;

  void __set_domainName(const std::string& val);

  void __set_diskPath(const std::string& val);

  bool operator == (const Aim_getDomainBlockInfo_args & rhs) const
  {
    if (!(domainName == rhs.domainName))
      return false;
    if (!(diskPath == rhs.diskPath))
      return false;
    return true;
  }
  bool operator != (const Aim_getDomainBlockInfo_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_getDomainBlockInfo_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_getDomainBlockInfo_args& obj);
};


class Aim_getDomainBlockInfo_pargs {
 public:

  static const char* ascii_fingerprint; // = "07A9615F837F7D0A952B595DD3020972";
  static const uint8_t binary_fingerprint[16]; // = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};


  virtual ~Aim_getDomainBlockInfo_pargs() throw();
  const std::string* domainName;
  const std::string* diskPath;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_getDomainBlockInfo_pargs& obj);
};

typedef struct _Aim_getDomainBlockInfo_result__isset {
  _Aim_getDomainBlockInfo_result__isset() : success(false), libvirtException(false) {}
  bool success :1;
  bool libvirtException :1;
} _Aim_getDomainBlockInfo_result__isset;

class Aim_getDomainBlockInfo_result {
 public:

  static const char* ascii_fingerprint; // = "157676735ACB58A8048DF5346496F74C";
  static const uint8_t binary_fingerprint[16]; // = {0x15,0x76,0x76,0x73,0x5A,0xCB,0x58,0xA8,0x04,0x8D,0xF5,0x34,0x64,0x96,0xF7,0x4C};

  Aim_getDomainBlockInfo_result(const Aim_getDomainBlockInfo_result&);
  Aim_getDomainBlockInfo_result& operator=(const Aim_getDomainBlockInfo_result&);
  Aim_getDomainBlockInfo_result() {
  }

  virtual ~Aim_getDomainBlockInfo_result() throw();
  DomainBlockInfo success;
  LibvirtException libvirtException;

  _Aim_getDomainBlockInfo_result__isset __isset;

  void __set_success(const DomainBlockInfo& val);

  void __set_libvirtException(const LibvirtException& val);

  bool operator == (const Aim_getDomainBlockInfo_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(libvirtException == rhs.libvirtException))
      return false;
    return true;
  }
  bool operator != (const Aim_getDomainBlockInfo_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_getDomainBlockInfo_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_getDomainBlockInfo_result& obj);
};

typedef struct _Aim_getDomainBlockInfo_presult__isset {
  _Aim_getDomainBlockInfo_presult__isset() : success(false), libvirtException(false) {}
  bool success :1;
  bool libvirtException :1;
} _Aim_getDomainBlockInfo_presult__isset;

class Aim_getDomainBlockInfo_presult {
 public:

  static const char* ascii_fingerprint; // = "157676735ACB58A8048DF5346496F74C";
  static const uint8_t binary_fingerprint[16]; // = {0x15,0x76,0x76,0x73,0x5A,0xCB,0x58,0xA8,0x04,0x8D,0xF5,0x34,0x64,0x96,0xF7,0x4C};


  virtual ~Aim_getDomainBlockInfo_presult() throw();
  DomainBlockInfo* success;
  LibvirtException libvirtException;

  _Aim_getDomainBlockInfo_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Aim_getDomainBlockInfo_presult& obj);
};

typedef struct _Aim_getDatapoints_args__isset {
  _Aim_getDatapoints_args__isset() : domainName(false), timestamp(false) {}
  bool domainName :1;
  bool timestamp :1;
} _Aim_getDatapoints_args__isset;

class Aim_getDatapoints_args {
 public:

  static const char* ascii_fingerprint; // = "EEBC915CE44901401D881E6091423036";
  static const uint8_t binary_fingerprint[16]; // = {0xEE,0xBC,0x91,0x5C,0xE4,0x49,0x01,0x40,0x1D,0x88,0x1E,0x60,0x91,0x42,0x30,0x36};

  Aim_getDatapoints_args(const Aim_getDatapoints_args&);
  Aim_getDatapoints_args& operator=(const Aim_getDatapoints_args&);
  Aim_getDatapoints_args() : domainName(), timestamp(0) {
  }

  virtual ~Aim_getDatapoints_args() throw();
  std::string domainName;
  int32_t timestamp;

  _Aim_getDatapoints_args__isset __isset;

  void __set_domainName(const std::string& val);

  void __set_timestamp(const int32_t val);

  bool operator == (const Aim_getDatapoints_args & rhs) const
  {
    if (!(domainName == rhs.domainName))
      return false;
    if (!(timestamp == rhs.timestamp))
      return false;
    return true;
  }
  bool operator != (const Aim_getDatapoints_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_getDatapoints_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_getDatapoints_args& obj);
};


class Aim_getDatapoints_pargs {
 public:

  static const char* ascii_fingerprint; // = "EEBC915CE44901401D881E6091423036";
  static const uint8_t binary_fingerprint[16]; // = {0xEE,0xBC,0x91,0x5C,0xE4,0x49,0x01,0x40,0x1D,0x88,0x1E,0x60,0x91,0x42,0x30,0x36};


  virtual ~Aim_getDatapoints_pargs() throw();
  const std::string* domainName;
  const int32_t* timestamp;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_getDatapoints_pargs& obj);
};

typedef struct _Aim_getDatapoints_result__isset {
  _Aim_getDatapoints_result__isset() : success(false) {}
  bool success :1;
} _Aim_getDatapoints_result__isset;

class Aim_getDatapoints_result {
 public:

  static const char* ascii_fingerprint; // = "D1E436EC019DB1D4F6EF23DE9D2CB9F9";
  static const uint8_t binary_fingerprint[16]; // = {0xD1,0xE4,0x36,0xEC,0x01,0x9D,0xB1,0xD4,0xF6,0xEF,0x23,0xDE,0x9D,0x2C,0xB9,0xF9};

  Aim_getDatapoints_result(const Aim_getDatapoints_result&);
  Aim_getDatapoints_result& operator=(const Aim_getDatapoints_result&);
  Aim_getDatapoints_result() {
  }

  virtual ~Aim_getDatapoints_result() throw();
  std::vector<Measure>  success;

  _Aim_getDatapoints_result__isset __isset;

  void __set_success(const std::vector<Measure> & val);

  bool operator == (const Aim_getDatapoints_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Aim_getDatapoints_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_getDatapoints_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_getDatapoints_result& obj);
};

typedef struct _Aim_getDatapoints_presult__isset {
  _Aim_getDatapoints_presult__isset() : success(false) {}
  bool success :1;
} _Aim_getDatapoints_presult__isset;

class Aim_getDatapoints_presult {
 public:

  static const char* ascii_fingerprint; // = "D1E436EC019DB1D4F6EF23DE9D2CB9F9";
  static const uint8_t binary_fingerprint[16]; // = {0xD1,0xE4,0x36,0xEC,0x01,0x9D,0xB1,0xD4,0xF6,0xEF,0x23,0xDE,0x9D,0x2C,0xB9,0xF9};


  virtual ~Aim_getDatapoints_presult() throw();
  std::vector<Measure> * success;

  _Aim_getDatapoints_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Aim_getDatapoints_presult& obj);
};

typedef struct _Aim_upload_args__isset {
  _Aim_upload_args__isset() : file(false), path(false) {}
  bool file :1;
  bool path :1;
} _Aim_upload_args__isset;

class Aim_upload_args {
 public:

  static const char* ascii_fingerprint; // = "BDAF55DAA660FA1ADBE30760752211A8";
  static const uint8_t binary_fingerprint[16]; // = {0xBD,0xAF,0x55,0xDA,0xA6,0x60,0xFA,0x1A,0xDB,0xE3,0x07,0x60,0x75,0x22,0x11,0xA8};

  Aim_upload_args(const Aim_upload_args&);
  Aim_upload_args& operator=(const Aim_upload_args&);
  Aim_upload_args() : path() {
  }

  virtual ~Aim_upload_args() throw();
  BinaryFile file;
  std::string path;

  _Aim_upload_args__isset __isset;

  void __set_file(const BinaryFile& val);

  void __set_path(const std::string& val);

  bool operator == (const Aim_upload_args & rhs) const
  {
    if (!(file == rhs.file))
      return false;
    if (!(path == rhs.path))
      return false;
    return true;
  }
  bool operator != (const Aim_upload_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_upload_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_upload_args& obj);
};


class Aim_upload_pargs {
 public:

  static const char* ascii_fingerprint; // = "BDAF55DAA660FA1ADBE30760752211A8";
  static const uint8_t binary_fingerprint[16]; // = {0xBD,0xAF,0x55,0xDA,0xA6,0x60,0xFA,0x1A,0xDB,0xE3,0x07,0x60,0x75,0x22,0x11,0xA8};


  virtual ~Aim_upload_pargs() throw();
  const BinaryFile* file;
  const std::string* path;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_upload_pargs& obj);
};


class Aim_upload_result {
 public:

  static const char* ascii_fingerprint; // = "99914B932BD37A50B983C5E7C90AE93B";
  static const uint8_t binary_fingerprint[16]; // = {0x99,0x91,0x4B,0x93,0x2B,0xD3,0x7A,0x50,0xB9,0x83,0xC5,0xE7,0xC9,0x0A,0xE9,0x3B};

  Aim_upload_result(const Aim_upload_result&);
  Aim_upload_result& operator=(const Aim_upload_result&);
  Aim_upload_result() {
  }

  virtual ~Aim_upload_result() throw();

  bool operator == (const Aim_upload_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Aim_upload_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Aim_upload_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Aim_upload_result& obj);
};


class Aim_upload_presult {
 public:

  static const char* ascii_fingerprint; // = "99914B932BD37A50B983C5E7C90AE93B";
  static const uint8_t binary_fingerprint[16]; // = {0x99,0x91,0x4B,0x93,0x2B,0xD3,0x7A,0x50,0xB9,0x83,0xC5,0xE7,0xC9,0x0A,0xE9,0x3B};


  virtual ~Aim_upload_presult() throw();

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Aim_upload_presult& obj);
};

class AimClient : virtual public AimIf {
 public:
  AimClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
    setProtocol(prot);
  }
  AimClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    setProtocol(iprot,oprot);
  }
 private:
  void setProtocol(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
  setProtocol(prot,prot);
  }
  void setProtocol(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  void checkRimpConfiguration();
  void send_checkRimpConfiguration();
  void recv_checkRimpConfiguration();
  int64_t getDiskFileSize(const std::string& virtualImageDatastorePath);
  void send_getDiskFileSize(const std::string& virtualImageDatastorePath);
  int64_t recv_getDiskFileSize();
  void getDatastores(std::vector<Datastore> & _return);
  void send_getDatastores();
  void recv_getDatastores(std::vector<Datastore> & _return);
  void getNetInterfaces(std::vector<NetInterface> & _return);
  void send_getNetInterfaces();
  void recv_getNetInterfaces(std::vector<NetInterface> & _return);
  void copyFromRepositoryToDatastore(const std::string& virtualImageRepositoryPath, const std::string& datastorePath, const std::string& virtualMachineUUID);
  void send_copyFromRepositoryToDatastore(const std::string& virtualImageRepositoryPath, const std::string& datastorePath, const std::string& virtualMachineUUID);
  void recv_copyFromRepositoryToDatastore();
  void deleteVirtualImageFromDatastore(const std::string& datastorePath, const std::string& virtualMachineUUID);
  void send_deleteVirtualImageFromDatastore(const std::string& datastorePath, const std::string& virtualMachineUUID);
  void recv_deleteVirtualImageFromDatastore();
  void copyFromDatastoreToRepository(const std::string& virtualMachineUUID, const std::string& snapshot, const std::string& destinationRepositoryPath, const std::string& sourceDatastorePath);
  void send_copyFromDatastoreToRepository(const std::string& virtualMachineUUID, const std::string& snapshot, const std::string& destinationRepositoryPath, const std::string& sourceDatastorePath);
  void recv_copyFromDatastoreToRepository();
  void instanceDisk(const std::string& source, const std::string& destination);
  void send_instanceDisk(const std::string& source, const std::string& destination);
  void recv_instanceDisk();
  void renameDisk(const std::string& oldPath, const std::string& newPath);
  void send_renameDisk(const std::string& oldPath, const std::string& newPath);
  void recv_renameDisk();
  void createVLAN(const int32_t vlanTag, const std::string& vlanInterface, const std::string& bridgeInterface);
  void send_createVLAN(const int32_t vlanTag, const std::string& vlanInterface, const std::string& bridgeInterface);
  void recv_createVLAN();
  void deleteVLAN(const int32_t vlanTag, const std::string& vlanInterface, const std::string& bridgeInterface);
  void send_deleteVLAN(const int32_t vlanTag, const std::string& vlanInterface, const std::string& bridgeInterface);
  void recv_deleteVLAN();
  void checkVLANConfiguration();
  void send_checkVLANConfiguration();
  void recv_checkVLANConfiguration();
  void getInitiatorIQN(std::string& _return);
  void send_getInitiatorIQN();
  void recv_getInitiatorIQN(std::string& _return);
  void rescanISCSI(const std::vector<std::string> & targets);
  void send_rescanISCSI(const std::vector<std::string> & targets);
  void recv_rescanISCSI();
  void getNodeInfo(NodeInfo& _return);
  void send_getNodeInfo();
  void recv_getNodeInfo(NodeInfo& _return);
  void defineDomain(const std::string& xmlDesc);
  void send_defineDomain(const std::string& xmlDesc);
  void recv_defineDomain();
  void undefineDomain(const std::string& domainName);
  void send_undefineDomain(const std::string& domainName);
  void recv_undefineDomain();
  bool existDomain(const std::string& domainName);
  void send_existDomain(const std::string& domainName);
  bool recv_existDomain();
  DomainState::type getDomainState(const std::string& domainName);
  void send_getDomainState(const std::string& domainName);
  DomainState::type recv_getDomainState();
  void getDomainInfo(DomainInfo& _return, const std::string& domainName);
  void send_getDomainInfo(const std::string& domainName);
  void recv_getDomainInfo(DomainInfo& _return);
  void getDomains(std::vector<DomainInfo> & _return);
  void send_getDomains();
  void recv_getDomains(std::vector<DomainInfo> & _return);
  void powerOn(const std::string& domainName);
  void send_powerOn(const std::string& domainName);
  void recv_powerOn();
  void powerOff(const std::string& domainName);
  void send_powerOff(const std::string& domainName);
  void recv_powerOff();
  void shutdown(const std::string& domainName);
  void send_shutdown(const std::string& domainName);
  void recv_shutdown();
  void reset(const std::string& domainName);
  void send_reset(const std::string& domainName);
  void recv_reset();
  void pause(const std::string& domainName);
  void send_pause(const std::string& domainName);
  void recv_pause();
  void resume(const std::string& domainName);
  void send_resume(const std::string& domainName);
  void recv_resume();
  void createISCSIStoragePool(const std::string& name, const std::string& host, const std::string& iqn, const std::string& targetPath);
  void send_createISCSIStoragePool(const std::string& name, const std::string& host, const std::string& iqn, const std::string& targetPath);
  void recv_createISCSIStoragePool();
  void createNFSStoragePool(const std::string& name, const std::string& host, const std::string& dir, const std::string& targetPath);
  void send_createNFSStoragePool(const std::string& name, const std::string& host, const std::string& dir, const std::string& targetPath);
  void recv_createNFSStoragePool();
  void createDirStoragePool(const std::string& name, const std::string& targetPath);
  void send_createDirStoragePool(const std::string& name, const std::string& targetPath);
  void recv_createDirStoragePool();
  void createDisk(const std::string& poolName, const std::string& name, const double capacityInKb, const double allocationInKb, const std::string& format);
  void send_createDisk(const std::string& poolName, const std::string& name, const double capacityInKb, const double allocationInKb, const std::string& format);
  void recv_createDisk();
  void deleteDisk(const std::string& poolName, const std::string& name);
  void send_deleteDisk(const std::string& poolName, const std::string& name);
  void recv_deleteDisk();
  void resizeVol(const std::string& poolName, const std::string& name, const double capacityInKb);
  void send_resizeVol(const std::string& poolName, const std::string& name, const double capacityInKb);
  void recv_resizeVol();
  void resizeDisk(const std::string& domainName, const std::string& diskPath, const double diskSizeInKb);
  void send_resizeDisk(const std::string& domainName, const std::string& diskPath, const double diskSizeInKb);
  void recv_resizeDisk();
  void getDomainBlockInfo(DomainBlockInfo& _return, const std::string& domainName, const std::string& diskPath);
  void send_getDomainBlockInfo(const std::string& domainName, const std::string& diskPath);
  void recv_getDomainBlockInfo(DomainBlockInfo& _return);
  void getDatapoints(std::vector<Measure> & _return, const std::string& domainName, const int32_t timestamp);
  void send_getDatapoints(const std::string& domainName, const int32_t timestamp);
  void recv_getDatapoints(std::vector<Measure> & _return);
  void upload(const BinaryFile& file, const std::string& path);
  void send_upload(const BinaryFile& file, const std::string& path);
  void recv_upload();
 protected:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
};

class AimProcessor : public ::apache::thrift::TDispatchProcessor {
 protected:
  boost::shared_ptr<AimIf> iface_;
  virtual bool dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext);
 private:
  typedef  void (AimProcessor::*ProcessFunction)(int32_t, ::apache::thrift::protocol::TProtocol*, ::apache::thrift::protocol::TProtocol*, void*);
  typedef std::map<std::string, ProcessFunction> ProcessMap;
  ProcessMap processMap_;
  void process_checkRimpConfiguration(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getDiskFileSize(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getDatastores(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getNetInterfaces(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_copyFromRepositoryToDatastore(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_deleteVirtualImageFromDatastore(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_copyFromDatastoreToRepository(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_instanceDisk(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_renameDisk(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_createVLAN(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_deleteVLAN(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_checkVLANConfiguration(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getInitiatorIQN(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_rescanISCSI(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getNodeInfo(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_defineDomain(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_undefineDomain(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_existDomain(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getDomainState(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getDomainInfo(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getDomains(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_powerOn(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_powerOff(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_shutdown(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_reset(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_pause(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_resume(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_createISCSIStoragePool(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_createNFSStoragePool(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_createDirStoragePool(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_createDisk(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_deleteDisk(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_resizeVol(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_resizeDisk(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getDomainBlockInfo(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getDatapoints(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_upload(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
 public:
  AimProcessor(boost::shared_ptr<AimIf> iface) :
    iface_(iface) {
    processMap_["checkRimpConfiguration"] = &AimProcessor::process_checkRimpConfiguration;
    processMap_["getDiskFileSize"] = &AimProcessor::process_getDiskFileSize;
    processMap_["getDatastores"] = &AimProcessor::process_getDatastores;
    processMap_["getNetInterfaces"] = &AimProcessor::process_getNetInterfaces;
    processMap_["copyFromRepositoryToDatastore"] = &AimProcessor::process_copyFromRepositoryToDatastore;
    processMap_["deleteVirtualImageFromDatastore"] = &AimProcessor::process_deleteVirtualImageFromDatastore;
    processMap_["copyFromDatastoreToRepository"] = &AimProcessor::process_copyFromDatastoreToRepository;
    processMap_["instanceDisk"] = &AimProcessor::process_instanceDisk;
    processMap_["renameDisk"] = &AimProcessor::process_renameDisk;
    processMap_["createVLAN"] = &AimProcessor::process_createVLAN;
    processMap_["deleteVLAN"] = &AimProcessor::process_deleteVLAN;
    processMap_["checkVLANConfiguration"] = &AimProcessor::process_checkVLANConfiguration;
    processMap_["getInitiatorIQN"] = &AimProcessor::process_getInitiatorIQN;
    processMap_["rescanISCSI"] = &AimProcessor::process_rescanISCSI;
    processMap_["getNodeInfo"] = &AimProcessor::process_getNodeInfo;
    processMap_["defineDomain"] = &AimProcessor::process_defineDomain;
    processMap_["undefineDomain"] = &AimProcessor::process_undefineDomain;
    processMap_["existDomain"] = &AimProcessor::process_existDomain;
    processMap_["getDomainState"] = &AimProcessor::process_getDomainState;
    processMap_["getDomainInfo"] = &AimProcessor::process_getDomainInfo;
    processMap_["getDomains"] = &AimProcessor::process_getDomains;
    processMap_["powerOn"] = &AimProcessor::process_powerOn;
    processMap_["powerOff"] = &AimProcessor::process_powerOff;
    processMap_["shutdown"] = &AimProcessor::process_shutdown;
    processMap_["reset"] = &AimProcessor::process_reset;
    processMap_["pause"] = &AimProcessor::process_pause;
    processMap_["resume"] = &AimProcessor::process_resume;
    processMap_["createISCSIStoragePool"] = &AimProcessor::process_createISCSIStoragePool;
    processMap_["createNFSStoragePool"] = &AimProcessor::process_createNFSStoragePool;
    processMap_["createDirStoragePool"] = &AimProcessor::process_createDirStoragePool;
    processMap_["createDisk"] = &AimProcessor::process_createDisk;
    processMap_["deleteDisk"] = &AimProcessor::process_deleteDisk;
    processMap_["resizeVol"] = &AimProcessor::process_resizeVol;
    processMap_["resizeDisk"] = &AimProcessor::process_resizeDisk;
    processMap_["getDomainBlockInfo"] = &AimProcessor::process_getDomainBlockInfo;
    processMap_["getDatapoints"] = &AimProcessor::process_getDatapoints;
    processMap_["upload"] = &AimProcessor::process_upload;
  }

  virtual ~AimProcessor() {}
};

class AimProcessorFactory : public ::apache::thrift::TProcessorFactory {
 public:
  AimProcessorFactory(const ::boost::shared_ptr< AimIfFactory >& handlerFactory) :
      handlerFactory_(handlerFactory) {}

  ::boost::shared_ptr< ::apache::thrift::TProcessor > getProcessor(const ::apache::thrift::TConnectionInfo& connInfo);

 protected:
  ::boost::shared_ptr< AimIfFactory > handlerFactory_;
};

class AimMultiface : virtual public AimIf {
 public:
  AimMultiface(std::vector<boost::shared_ptr<AimIf> >& ifaces) : ifaces_(ifaces) {
  }
  virtual ~AimMultiface() {}
 protected:
  std::vector<boost::shared_ptr<AimIf> > ifaces_;
  AimMultiface() {}
  void add(boost::shared_ptr<AimIf> iface) {
    ifaces_.push_back(iface);
  }
 public:
  void checkRimpConfiguration() {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->checkRimpConfiguration();
    }
    ifaces_[i]->checkRimpConfiguration();
  }

  int64_t getDiskFileSize(const std::string& virtualImageDatastorePath) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getDiskFileSize(virtualImageDatastorePath);
    }
    return ifaces_[i]->getDiskFileSize(virtualImageDatastorePath);
  }

  void getDatastores(std::vector<Datastore> & _return) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getDatastores(_return);
    }
    ifaces_[i]->getDatastores(_return);
    return;
  }

  void getNetInterfaces(std::vector<NetInterface> & _return) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getNetInterfaces(_return);
    }
    ifaces_[i]->getNetInterfaces(_return);
    return;
  }

  void copyFromRepositoryToDatastore(const std::string& virtualImageRepositoryPath, const std::string& datastorePath, const std::string& virtualMachineUUID) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->copyFromRepositoryToDatastore(virtualImageRepositoryPath, datastorePath, virtualMachineUUID);
    }
    ifaces_[i]->copyFromRepositoryToDatastore(virtualImageRepositoryPath, datastorePath, virtualMachineUUID);
  }

  void deleteVirtualImageFromDatastore(const std::string& datastorePath, const std::string& virtualMachineUUID) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->deleteVirtualImageFromDatastore(datastorePath, virtualMachineUUID);
    }
    ifaces_[i]->deleteVirtualImageFromDatastore(datastorePath, virtualMachineUUID);
  }

  void copyFromDatastoreToRepository(const std::string& virtualMachineUUID, const std::string& snapshot, const std::string& destinationRepositoryPath, const std::string& sourceDatastorePath) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->copyFromDatastoreToRepository(virtualMachineUUID, snapshot, destinationRepositoryPath, sourceDatastorePath);
    }
    ifaces_[i]->copyFromDatastoreToRepository(virtualMachineUUID, snapshot, destinationRepositoryPath, sourceDatastorePath);
  }

  void instanceDisk(const std::string& source, const std::string& destination) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->instanceDisk(source, destination);
    }
    ifaces_[i]->instanceDisk(source, destination);
  }

  void renameDisk(const std::string& oldPath, const std::string& newPath) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->renameDisk(oldPath, newPath);
    }
    ifaces_[i]->renameDisk(oldPath, newPath);
  }

  void createVLAN(const int32_t vlanTag, const std::string& vlanInterface, const std::string& bridgeInterface) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->createVLAN(vlanTag, vlanInterface, bridgeInterface);
    }
    ifaces_[i]->createVLAN(vlanTag, vlanInterface, bridgeInterface);
  }

  void deleteVLAN(const int32_t vlanTag, const std::string& vlanInterface, const std::string& bridgeInterface) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->deleteVLAN(vlanTag, vlanInterface, bridgeInterface);
    }
    ifaces_[i]->deleteVLAN(vlanTag, vlanInterface, bridgeInterface);
  }

  void checkVLANConfiguration() {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->checkVLANConfiguration();
    }
    ifaces_[i]->checkVLANConfiguration();
  }

  void getInitiatorIQN(std::string& _return) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getInitiatorIQN(_return);
    }
    ifaces_[i]->getInitiatorIQN(_return);
    return;
  }

  void rescanISCSI(const std::vector<std::string> & targets) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->rescanISCSI(targets);
    }
    ifaces_[i]->rescanISCSI(targets);
  }

  void getNodeInfo(NodeInfo& _return) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getNodeInfo(_return);
    }
    ifaces_[i]->getNodeInfo(_return);
    return;
  }

  void defineDomain(const std::string& xmlDesc) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->defineDomain(xmlDesc);
    }
    ifaces_[i]->defineDomain(xmlDesc);
  }

  void undefineDomain(const std::string& domainName) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->undefineDomain(domainName);
    }
    ifaces_[i]->undefineDomain(domainName);
  }

  bool existDomain(const std::string& domainName) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->existDomain(domainName);
    }
    return ifaces_[i]->existDomain(domainName);
  }

  DomainState::type getDomainState(const std::string& domainName) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getDomainState(domainName);
    }
    return ifaces_[i]->getDomainState(domainName);
  }

  void getDomainInfo(DomainInfo& _return, const std::string& domainName) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getDomainInfo(_return, domainName);
    }
    ifaces_[i]->getDomainInfo(_return, domainName);
    return;
  }

  void getDomains(std::vector<DomainInfo> & _return) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getDomains(_return);
    }
    ifaces_[i]->getDomains(_return);
    return;
  }

  void powerOn(const std::string& domainName) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->powerOn(domainName);
    }
    ifaces_[i]->powerOn(domainName);
  }

  void powerOff(const std::string& domainName) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->powerOff(domainName);
    }
    ifaces_[i]->powerOff(domainName);
  }

  void shutdown(const std::string& domainName) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->shutdown(domainName);
    }
    ifaces_[i]->shutdown(domainName);
  }

  void reset(const std::string& domainName) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->reset(domainName);
    }
    ifaces_[i]->reset(domainName);
  }

  void pause(const std::string& domainName) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->pause(domainName);
    }
    ifaces_[i]->pause(domainName);
  }

  void resume(const std::string& domainName) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->resume(domainName);
    }
    ifaces_[i]->resume(domainName);
  }

  void createISCSIStoragePool(const std::string& name, const std::string& host, const std::string& iqn, const std::string& targetPath) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->createISCSIStoragePool(name, host, iqn, targetPath);
    }
    ifaces_[i]->createISCSIStoragePool(name, host, iqn, targetPath);
  }

  void createNFSStoragePool(const std::string& name, const std::string& host, const std::string& dir, const std::string& targetPath) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->createNFSStoragePool(name, host, dir, targetPath);
    }
    ifaces_[i]->createNFSStoragePool(name, host, dir, targetPath);
  }

  void createDirStoragePool(const std::string& name, const std::string& targetPath) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->createDirStoragePool(name, targetPath);
    }
    ifaces_[i]->createDirStoragePool(name, targetPath);
  }

  void createDisk(const std::string& poolName, const std::string& name, const double capacityInKb, const double allocationInKb, const std::string& format) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->createDisk(poolName, name, capacityInKb, allocationInKb, format);
    }
    ifaces_[i]->createDisk(poolName, name, capacityInKb, allocationInKb, format);
  }

  void deleteDisk(const std::string& poolName, const std::string& name) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->deleteDisk(poolName, name);
    }
    ifaces_[i]->deleteDisk(poolName, name);
  }

  void resizeVol(const std::string& poolName, const std::string& name, const double capacityInKb) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->resizeVol(poolName, name, capacityInKb);
    }
    ifaces_[i]->resizeVol(poolName, name, capacityInKb);
  }

  void resizeDisk(const std::string& domainName, const std::string& diskPath, const double diskSizeInKb) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->resizeDisk(domainName, diskPath, diskSizeInKb);
    }
    ifaces_[i]->resizeDisk(domainName, diskPath, diskSizeInKb);
  }

  void getDomainBlockInfo(DomainBlockInfo& _return, const std::string& domainName, const std::string& diskPath) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getDomainBlockInfo(_return, domainName, diskPath);
    }
    ifaces_[i]->getDomainBlockInfo(_return, domainName, diskPath);
    return;
  }

  void getDatapoints(std::vector<Measure> & _return, const std::string& domainName, const int32_t timestamp) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getDatapoints(_return, domainName, timestamp);
    }
    ifaces_[i]->getDatapoints(_return, domainName, timestamp);
    return;
  }

  void upload(const BinaryFile& file, const std::string& path) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->upload(file, path);
    }
    ifaces_[i]->upload(file, path);
  }

};



#endif
